<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcolo Costi Logistici</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const Calculator = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/></svg>;
        const TrendingDown = () => <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 18 13.5 8.5 8.5 13.5 1 6"/><polyline points="17 18 23 18 23 12"/></svg>;
        const Package = () => <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>;
        const Truck = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="1" y="3" width="15" height="13"/><circle cx="5.5" cy="18.5" r="2.5"/></svg>;
        const MapPin = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>;
        const AlertCircle = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/></svg>;
        const Loader = () => <svg className="animate-spin" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/></svg>;

        const App = () => {
          const [excelData, setExcelData] = useState(null);
          const [destinazione, setDestinazione] = useState('');
          const [modalita, setModalita] = useState('');
          const [tonnellate, setTonnellate] = useState('');
          const [risultato, setRisultato] = useState(null);
          const [availableDestinations, setAvailableDestinations] = useState([]);
          const [isCalculating, setIsCalculating] = useState(false);
          const [isLoading, setIsLoading] = useState(true);
          const [dataError, setDataError] = useState(false);
          const [errorMessage, setErrorMessage] = useState('');

          const GOOGLE_SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-MthW0ItRfSSthoga_Tvd7w1_OMdDXZylZQhLjG5I0bk1cEGZjqPsFUt6I373L4oFpw156lvbvYHJ/pub?output=csv';

          useEffect(() => {
            loadData();
          }, []);

          const parseCSVLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          };

          const loadData = async () => {
            try {
              setIsLoading(true);
              setDataError(false);
              console.log('Caricamento da:', GOOGLE_SHEET_CSV_URL);

              const response = await fetch(GOOGLE_SHEET_CSV_URL);
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              
              const csvText = await response.text();
              console.log('CSV caricato, primi 500 caratteri:', csvText.substring(0, 500));
              
              const lines = csvText.split('\n');
              const headers = parseCSVLine(lines[0]);
              
              console.log('Headers:', headers);
              
              const data = [];
              for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                const row = {};
                
                headers.forEach((header, index) => {
                  let value = values[index] || '';
                  
                  const numValue = value.replace(',', '.');
                  if (!isNaN(numValue) && numValue !== '') {
                    row[header] = parseFloat(numValue);
                  } else {
                    row[header] = value;
                  }
                });
                
                if (row.ORDINE && row['€/TON']) {
                  data.push(row);
                }
              }
              
              console.log('Dati caricati:', data.length);
              if (data.length > 0) {
                console.log('Primo ordine:', data[0]);
                console.log('Ultimo ordine:', data[data.length - 1]);
              }
              
              setExcelData(data);
              const dests = [...new Set(data.map(r => r.DESTINAZIONE).filter(Boolean))];
              setAvailableDestinations(dests.sort());
              
            } catch (error) {
              console.error('ERRORE:', error);
              setDataError(true);
              setErrorMessage(error.message);
            } finally {
              setIsLoading(false);
            }
          };

          const getCoordinates = async (address) => {
            const normalized = address.toLowerCase().trim();
            
            // Database locale con coordinate precise
            const cities = {
              'milano': { lat: 45.4642, lon: 9.19 },
              'roma': { lat: 41.9028, lon: 12.4964 },
              'napoli': { lat: 40.8518, lon: 14.2681 },
              'verona': { lat: 45.4384, lon: 10.9916 },
              'brescia': { lat: 45.5416, lon: 10.2118 },
              'oppeano': { lat: 45.316722, lon: 11.099167 }, // Coordinate precise corrette
              'adro': { lat: 45.6167, lon: 9.9667 },
              'salerno': { lat: 40.6824, lon: 14.7681 },
              'bergamo': { lat: 45.6983, lon: 9.6773 },
              'mantova': { lat: 45.1564, lon: 10.7914 },
              'cremona': { lat: 45.1333, lon: 10.0167 },
              'pavia': { lat: 45.1847, lon: 9.1582 },
              'torino': { lat: 45.0703, lon: 7.6869 },
              'genova': { lat: 44.4056, lon: 8.9463 },
              'bologna': { lat: 44.4949, lon: 11.3426 },
              'firenze': { lat: 43.7696, lon: 11.2558 },
              'venezia': { lat: 45.4408, lon: 12.3155 },
              'padova': { lat: 45.4064, lon: 11.8768 },
              'vicenza': { lat: 45.5455, lon: 11.5354 },
              'treviso': { lat: 45.6669, lon: 12.243 }
            };
            
            for (const [city, coords] of Object.entries(cities)) {
              if (normalized.includes(city)) {
                return coords;
              }
            }

            try {
              await new Promise(resolve => setTimeout(resolve, 500));
              const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}, Italy&limit=1`,
                { headers: { 'User-Agent': 'LogisticsCostCalculator/1.0' } }
              );
              const data = await response.json();
              if (data && data.length > 0) {
                // Mantieni precisione usando Number() invece di parseFloat()
                // e arrotonda a 6 decimali (sufficiente per ~11cm di precisione)
                const lat = Number(Number(data[0].lat).toFixed(6));
                const lon = Number(Number(data[0].lon).toFixed(6));
                console.log(`Geocoded "${address}":`, { lat, lon });
                return { lat, lon };
              }
            } catch (error) {
              console.error('Geocoding error:', error);
            }
            return null;
          };

          const calculateDistance = async (c1, c2) => {
            try {
              // Usa OSRM per calcolare distanza stradale reale
              const url = `https://router.project-osrm.org/route/v1/driving/${c1.lon},${c1.lat};${c2.lon},${c2.lat}?overview=false`;
              const response = await fetch(url);
              
              if (!response.ok) {
                throw new Error('OSRM API error');
              }
              
              const data = await response.json();
              
              if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                // Distanza in metri, converti in km
                const distanceKm = data.routes[0].distance / 1000;
                return distanceKm;
              } else {
                // Fallback a Haversine se OSRM fallisce
                console.warn('OSRM fallito, uso Haversine');
                return calculateDistanceHaversine(c1, c2);
              }
            } catch (error) {
              console.error('Errore OSRM:', error);
              // Fallback a Haversine
              return calculateDistanceHaversine(c1, c2);
            }
          };
          
          const calculateDistanceHaversine = (c1, c2) => {
            // Formula di Haversine come fallback
            const R = 6371;
            const dLat = (c2.lat - c1.lat) * Math.PI / 180;
            const dLon = (c2.lon - c1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(c1.lat * Math.PI / 180) * Math.cos(c2.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
          };

          const calculateBestOption = async () => {
            if (!destinazione || !modalita || !tonnellate) {
              alert('Compila tutti i campi');
              return;
            }
            
            setIsCalculating(true);
            
            try {
              console.log('=== INIZIO CALCOLO ===');
              console.log('Modalità richiesta:', modalita);
              console.log('Totale ordini disponibili:', excelData.length);
              
              const filtered = excelData.filter(r => {
                const modalitaRow = r["MODALITA'"];
                const hasEuroTon = r['€/TON'];
                console.log('Ordine:', r.ORDINE, '- MODALITA\':', modalitaRow, '- Match:', modalitaRow === modalita, '- €/TON:', hasEuroTon);
                return modalitaRow === modalita && hasEuroTon;
              });
              
              console.log('Ordini filtrati per modalità "' + modalita + '":', filtered.length);
              if (filtered.length > 0) {
                console.log('Primo ordine filtrato:', filtered[0]);
              }
              
              if (filtered.length === 0) {
                alert('Nessun ordine per questa modalità');
                setIsCalculating(false);
                return;
              }
              
              const exact = filtered.filter(r => r.DESTINAZIONE === destinazione);
              
              let ordersToUse = [];
              let isEstimated = false;
              let referenceDestinations = [];
              
              if (exact.length > 0) {
                ordersToUse = exact;
              } else {
                isEstimated = true;
                const targetCoords = await getCoordinates(destinazione);
                
                if (!targetCoords) {
                  alert('Impossibile trovare la destinazione');
                  setIsCalculating(false);
                  return;
                }
                
                const destsWithDist = [];
                for (const row of filtered) {
                  const coords = await getCoordinates(row.DESTINAZIONE);
                  if (coords) {
                    const distance = await calculateDistance(targetCoords, coords);
                    destsWithDist.push({
                      destination: row.DESTINAZIONE,
                      distance: distance
                    });
                  }
                }
                
                destsWithDist.sort((a, b) => a.distance - b.distance);
                const nearest = destsWithDist.slice(0, 5);
                referenceDestinations = nearest;
                
                nearest.forEach(nd => {
                  const orders = filtered.filter(r => r.DESTINAZIONE === nd.destination);
                  ordersToUse.push(...orders);
                });
              }
              
              if (ordersToUse.length === 0) {
                alert('Nessun ordine trovato');
                setIsCalculating(false);
                return;
              }
              
              // Raggruppa per porto+forwarder
              const combinations = {};
              ordersToUse.forEach(order => {
                const key = `${order.PORTO}|${order.FORWARDER}`;
                if (!combinations[key]) {
                  combinations[key] = { 
                    porto: order.PORTO, 
                    forwarder: order.FORWARDER, 
                    costs: [],
                    destinations: []
                  };
                }
                combinations[key].costs.push(parseFloat(order['€/TON']));
                if (!combinations[key].destinations.includes(order.DESTINAZIONE)) {
                  combinations[key].destinations.push(order.DESTINAZIONE);
                }
              });
              
              // Definisci coordinate porti (disponibile per tutto il calcolo)
              const portCoords = {
                'VENEZIA': { lat: 45.4408, lon: 12.3155 },
                'TRIESTE': { lat: 45.6495, lon: 13.7768 },
                'GENOVA': { lat: 44.4056, lon: 8.9463 },
                'LIVORNO': { lat: 43.5485, lon: 10.3106 },
                'RAVENNA': { lat: 44.4184, lon: 12.2035 },
                'NAPOLI': { lat: 40.8518, lon: 14.2681 },
                'SALERNO': { lat: 40.6824, lon: 14.7681 },
                'CIVITAVECCHIA': { lat: 42.0938, lon: 11.7967 }
              };
              
              // Se è una stima, calcola distanza dei porti dalla destinazione target
              let bestOption = null;
              let lowestCost = Infinity;
              
              if (isEstimated) {
                const targetCoords = await getCoordinates(destinazione);
                console.log('=== CALCOLO DISTANZE PORTI ===');
                console.log('Destinazione richiesta:', destinazione);
                console.log('Coordinate destinazione:', targetCoords);
                
                // Per ogni combinazione, calcola distanza del porto
                const combosWithDistance = [];
                for (const combo of Object.values(combinations)) {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  const portCoord = portCoords[combo.porto.toUpperCase()];
                  
                  if (portCoord && targetCoords) {
                    const distance = await calculateDistance(targetCoords, portCoord);
                    console.log(`Porto ${combo.porto}:`, {
                      coordinate: portCoord,
                      distanza_km: distance.toFixed(1),
                      costo_medio: avgCost.toFixed(2),
                      num_ordini: combo.costs.length
                    });
                    
                    combosWithDistance.push({
                      ...combo,
                      avgCost,
                      numOrders: combo.costs.length,
                      portDistance: distance
                    });
                  } else {
                    console.log(`Porto ${combo.porto}: coordinate non trovate`);
                  }
                }
                
                console.log('--- Ordinamento porti ---');
                // Ordina per distanza porto, poi per costo
                combosWithDistance.sort((a, b) => {
                  // Prima criterio: distanza porto (peso maggiore)
                  const distDiff = a.portDistance - b.portDistance;
                  if (Math.abs(distDiff) > 100) return distDiff; // Se differenza >100km, conta molto
                  // Secondo criterio: costo
                  return a.avgCost - b.avgCost;
                });
                
                combosWithDistance.forEach((c, i) => {
                  console.log(`${i+1}. ${c.porto} - ${c.portDistance.toFixed(0)}km - €${c.avgCost.toFixed(2)}/ton`);
                });
                
                if (combosWithDistance.length > 0) {
                  bestOption = combosWithDistance[0];
                  console.log('✓ PORTO SCELTO:', bestOption.porto, '-', bestOption.portDistance.toFixed(0), 'km');
                }
                
              } else {
                // Match esatto: scegli solo per costo
                Object.values(combinations).forEach(combo => {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  if (avgCost < lowestCost) {
                    lowestCost = avgCost;
                    bestOption = { ...combo, avgCost, numOrders: combo.costs.length };
                  }
                });
              }
              
              const ton = parseFloat(tonnellate);
              
              // Calcola costi medi SOLO per il porto scelto e il forwarder scelto
              console.log('=== CALCOLO COSTI DETTAGLIATO ===');
              console.log('Porto scelto:', bestOption.porto);
              console.log('Forwarder scelto:', bestOption.forwarder);
              
              // Filtra ordini del porto+forwarder scelto
              const ordersForChosen = ordersToUse.filter(order => 
                order.PORTO === bestOption.porto && 
                order.FORWARDER === bestOption.forwarder
              );
              
              console.log('Ordini per porto+forwarder scelto:', ordersForChosen.length);
              
              let totalCostiFissi = 0;
              let totalInland = 0;
              let totalOrders = 0;
              
              ordersForChosen.forEach((order, idx) => {
                const freeOut = parseFloat(order['FREE OUT'] || 0);
                const deliveryOrder = parseFloat(order['DELIVERY ORDER'] || 0);
                const cicloTerminal = parseFloat(order['CICLO TERMINAL'] || 0);
                const dogana = parseFloat(order['DOGANA'] || 0);
                const dirittoFisso = parseFloat(order['DIRITTO FISSO'] || 0);
                const flegt = parseFloat(order['FLEGT'] || 0);
                const visitaMerce = parseFloat(order['VISITA MERCE'] || 0);
                const soste = parseFloat(order['SOSTE'] || 0);
                const svincolo = parseFloat(order['SVINCOLO'] || 0);
                const inland = parseFloat(order['INLAND'] || 0);
                
                // Costi fissi = tutti i costi TRANNE inland
                const costiFissi = freeOut + deliveryOrder + cicloTerminal + dogana + 
                                   dirittoFisso + flegt + visitaMerce + soste + svincolo;
                
                console.log(`Ordine ${idx+1} (${order.ORDINE}) - ${order.DESTINAZIONE}`);
                console.log('  Costi fissi:', costiFissi.toFixed(2), 
                           '(FREE OUT:', freeOut, 
                           '+ DELIVERY:', deliveryOrder,
                           '+ CICLO:', cicloTerminal, 
                           '+ DOGANA:', dogana,
                           '+ DIRITTO:', dirittoFisso,
                           '+ FLEGT:', flegt,
                           '+ VISITA:', visitaMerce,
                           '+ SOSTE:', soste,
                           '+ SVINCOLO:', svincolo, ')');
                console.log('  INLAND:', inland.toFixed(2));
                
                totalCostiFissi += costiFissi;
                totalInland += inland;
                totalOrders++;
              });
              
              const avgCostiFissi = totalCostiFissi / totalOrders;
              const avgInland = totalInland / totalOrders;
              
              console.log('--- MEDIE PER', bestOption.porto, '+', bestOption.forwarder, '---');
              console.log('MEDIA Costi Fissi:', avgCostiFissi.toFixed(2), '€');
              console.log('MEDIA INLAND:', avgInland.toFixed(2), '€');
              
              // Se è una stima, aggiusta l'INLAND in base alla distanza
              let adjustedInland = avgInland;
              if (isEstimated && referenceDestinations.length > 0) {
                const targetCoords = await getCoordinates(destinazione);
                
                // Calcola distanza media del porto scelto dalle sue destinazioni storiche
                let avgPortDistToRef = 0;
                let countDistances = 0;
                
                for (const order of ordersForChosen) {
                  const refCoords = await getCoordinates(order.DESTINAZIONE);
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (refCoords && portCoord) {
                    const dist = await calculateDistance(portCoord, refCoords);
                    avgPortDistToRef += dist;
                    countDistances++;
                  }
                }
                
                if (countDistances > 0) {
                  avgPortDistToRef = avgPortDistToRef / countDistances;
                  
                  // Calcola distanza porto dalla destinazione target
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (portCoord && targetCoords) {
                    const portDistToTarget = await calculateDistance(portCoord, targetCoords);
                    
                    // Aggiusta INLAND proporzionalmente alla differenza di distanza
                    const distanceRatio = portDistToTarget / avgPortDistToRef;
                    adjustedInland = avgInland * distanceRatio;
                    
                    console.log('=== STIMA INLAND ===');
                    console.log('INLAND medio storico (porto', bestOption.porto + '):', avgInland.toFixed(2), '€');
                    console.log('Distanza media porto→destinazioni storiche:', avgPortDistToRef.toFixed(0), 'km');
                    console.log('Distanza porto→target:', portDistToTarget.toFixed(0), 'km');
                    console.log('Ratio distanze:', distanceRatio.toFixed(2));
                    console.log('INLAND stimato:', adjustedInland.toFixed(2), '€');
                  }
                }
              }
              
              const costoTotalePerTon = (avgCostiFissi + adjustedInland) / ton;
              const costoTotale = avgCostiFissi + adjustedInland;
              
              setRisultato({
                porto: bestOption.porto,
                forwarder: bestOption.forwarder,
                costiFissi: avgCostiFissi.toFixed(2),
                inland: adjustedInland.toFixed(2),
                costoTotale: costoTotale.toFixed(2),
                costoPerTon: (costoTotale / ton).toFixed(2),
                tonnellate: ton,
                numOrdiniStorici: bestOption.numOrders,
                isEstimated: isEstimated,
                referenceDestinations: referenceDestinations
              });
              
            } catch (error) {
              console.error('Errore calcolo:', error);
              alert('Errore nel calcolo');
            } finally {
              setIsCalculating(false);
            }
          };

          if (isLoading) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                <div className="text-center">
                  <Loader />
                  <p className="text-gray-600 text-lg mt-4">Caricamento dati...</p>
                </div>
              </div>
            );
          }

          if (dataError) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md">
                  <AlertCircle />
                  <h2 className="text-xl font-bold mb-4">Errore Caricamento</h2>
                  <p className="text-gray-600 mb-4">Impossibile caricare i dati.</p>
                  <div className="bg-red-50 p-3 rounded mb-4">
                    <p className="text-sm text-red-800">{errorMessage}</p>
                  </div>
                  <p className="text-sm text-gray-600 mb-4">Apri Console (F12) per dettagli.</p>
                  <button onClick={loadData} className="w-full bg-indigo-600 text-white py-3 rounded-lg">Riprova</button>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
              <div className="max-w-3xl mx-auto">
                <div className="bg-white rounded-2xl shadow-xl p-8 mb-6">
                  <div className="flex items-center gap-3 mb-6">
                    <Package />
                    <h1 className="text-3xl font-bold text-gray-800">Calcolo Costi Logistici</h1>
                  </div>

                  <div className="bg-green-50 border-l-4 border-green-500 p-4 mb-6">
                    <p className="text-sm text-green-800">
                      <strong>✓ Connesso</strong> - {excelData.length} ordini caricati
                    </p>
                  </div>

                  <div className="space-y-6">
                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <MapPin />
                        Destinazione
                      </label>
                      <input
                        type="text"
                        value={destinazione}
                        onChange={(e) => setDestinazione(e.target.value)}
                        placeholder="es. Milano"
                        list="dests"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                      <datalist id="dests">
                        {availableDestinations.map(d => <option key={d} value={d} />)}
                      </datalist>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <Truck />
                        Modalità
                      </label>
                      <select value={modalita} onChange={(e) => setModalita(e.target.value)} className="w-full px-4 py-3 border rounded-lg">
                        <option value="">Seleziona...</option>
                        <option value="CONTAINER">Container</option>
                        <option value="TRUCK">Camion</option>
                      </select>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold">Tonnellate</label>
                      <input
                        type="number"
                        value={tonnellate}
                        onChange={(e) => setTonnellate(e.target.value)}
                        placeholder="es. 25"
                        step="0.01"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                    </div>

                    <button
                      onClick={calculateBestOption}
                      disabled={isCalculating}
                      className="w-full bg-indigo-600 text-white font-bold py-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-400"
                    >
                      <Calculator />
                      {isCalculating ? 'Calcolo...' : 'Calcola Preventivo'}
                    </button>
                  </div>
                </div>

                {risultato && (
                  <div className="bg-white rounded-2xl shadow-xl p-8">
                    {risultato.isEstimated && (
                      <div className="bg-amber-50 border-l-4 border-amber-500 p-4 mb-6">
                        <p className="text-sm text-amber-800">
                          <strong>⚠️ Stima</strong> - Basata su {risultato.referenceDestinations.length} destinazioni vicine
                        </p>
                      </div>
                    )}

                    <div className="flex items-center gap-3 mb-6">
                      <TrendingDown />
                      <h2 className="text-2xl font-bold">Preventivo</h2>
                    </div>

                    <div className="grid md:grid-cols-2 gap-4 mb-6">
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">Porto</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.porto}</p>
                      </div>
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">Forwarder</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.forwarder}</p>
                      </div>
                    </div>

                    <div className="bg-green-50 p-6 rounded-xl mb-6">
                      <h3 className="font-semibold text-gray-700 mb-4">Riepilogo Costi</h3>
                      <div className="space-y-3">
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">Costi Fissi (porto + dogana + servizi)</span>
                          <span className="text-lg font-bold text-gray-800">€{risultato.costiFissi}</span>
                        </div>
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">Inland (trasporto {risultato.porto} → destinazione)</span>
                          <span className="text-lg font-bold text-gray-800">€{risultato.inland}</span>
                        </div>
                        <div className="border-t-2 border-green-200 pt-3 mt-3">
                          <div className="flex justify-between items-center">
                            <span className="text-base font-semibold text-gray-700">Costo Totale</span>
                            <span className="text-2xl font-bold text-green-700">€{risultato.costoTotale}</span>
                          </div>
                          <div className="flex justify-between items-center mt-2">
                            <span className="text-sm text-gray-600">Costo per Tonnellata</span>
                            <span className="text-lg font-bold text-green-700">€{risultato.costoPerTon}/ton</span>
                          </div>
                          <p className="text-xs text-gray-500 mt-2">
                            ({risultato.tonnellate} tonnellate)
                          </p>
                        </div>
                      </div>
                    </div>

                    <p className="text-sm text-gray-500 mt-4">Basato su {risultato.numOrdiniStorici} ordini</p>
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
