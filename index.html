<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcolo Costi Logistici</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const Calculator = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/></svg>;
        const TrendingDown = () => <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 18 13.5 8.5 8.5 13.5 1 6"/><polyline points="17 18 23 18 23 12"/></svg>;
        const Package = () => <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>;
        const Truck = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="1" y="3" width="15" height="13"/><circle cx="5.5" cy="18.5" r="2.5"/></svg>;
        const MapPin = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>;
        const AlertCircle = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/></svg>;
        const Loader = () => <svg className="animate-spin" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/></svg>;

        const App = () => {
          const [excelData, setExcelData] = useState(null);
          const [tariffarioData, setTariffarioData] = useState(null);
          const [destinazione, setDestinazione] = useState('');
          const [modalita, setModalita] = useState('');
          const [tonnellate, setTonnellate] = useState('');
          const [risultato, setRisultato] = useState(null);
          const [availableDestinations, setAvailableDestinations] = useState([]);
          const [suggestedDestinations, setSuggestedDestinations] = useState([]);
          const [isCalculating, setIsCalculating] = useState(false);
          const [isLoading, setIsLoading] = useState(true);
          const [dataError, setDataError] = useState(false);
          const [errorMessage, setErrorMessage] = useState('');

          // URL per i due fogli
          const FOGLIO1_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-MthW0ItRfSSthoga_Tvd7w1_OMdDXZylZQhLjG5I0bk1cEGZjqPsFUt6I373L4oFpw156lvbvYHJ/pub?gid=0&single=true&output=csv';
          const FOGLIO2_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-MthW0ItRfSSthoga_Tvd7w1_OMdDXZylZQhLjG5I0bk1cEGZjqPsFUt6I373L4oFpw156lvbvYHJ/pub?gid=738284096&single=true&output=csv';

          useEffect(() => {
            loadData();
          }, []);

          const parseCSVLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              
              if (char === '"') {
                inQuotes = !inQuotes;
                // Non aggiungere le virgolette al valore
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          };

          const loadData = async () => {
            try {
              setIsLoading(true);
              setDataError(false);
              
              // Carica Foglio 1 (consuntivi)
              console.log('Caricamento Foglio 1:', FOGLIO1_CSV_URL);
              const response1 = await fetch(FOGLIO1_CSV_URL);
              if (!response1.ok) throw new Error(`HTTP ${response1.status} - Foglio 1`);
              
              const csvText1 = await response1.text();
              console.log('Foglio 1 caricato, primi 500 caratteri:', csvText1.substring(0, 500));
              
              const lines1 = csvText1.split('\n');
              const headers1 = parseCSVLine(lines1[0]);
              console.log('Headers Foglio 1:', headers1);
              
              const data1 = [];
              for (let i = 1; i < lines1.length; i++) {
                if (!lines1[i].trim()) continue;
                
                const values = parseCSVLine(lines1[i]);
                const row = {};
                
                headers1.forEach((header, index) => {
                  let value = values[index] || '';
                  
                  // Rimuovi caratteri non numerici (â‚¬, spazi)
                  let cleanValue = value.replace(/â‚¬/g, '').replace(/\s/g, '').trim();
                  
                  // Gestione formato italiano:
                  // Se contiene sia punto che virgola: 1.200,50 â†’ punto Ã¨ separatore migliaia
                  // Se contiene solo virgola: 1200,50 â†’ virgola Ã¨ decimale
                  // Se contiene solo punto: potrebbe essere 1.200 (migliaia) o 1.2 (decimale)
                  
                  if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    // Formato: 1.200,50 â†’ rimuovi punti, converti virgola in punto
                    cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                  } else if (cleanValue.includes(',')) {
                    // Formato: 1200,50 â†’ converti virgola in punto
                    cleanValue = cleanValue.replace(',', '.');
                  } else if (cleanValue.includes('.')) {
                    // Formato ambiguo: 1.200 o 1.2
                    // Se ci sono 3 cifre dopo il punto, Ã¨ separatore migliaia
                    const parts = cleanValue.split('.');
                    if (parts.length === 2 && parts[1].length === 3) {
                      // Es: 1.200 â†’ 1200
                      cleanValue = cleanValue.replace('.', '');
                    }
                    // Altrimenti lascia il punto come decimale
                  }
                  
                  if (!isNaN(cleanValue) && cleanValue !== '') {
                    row[header] = parseFloat(cleanValue);
                  } else {
                    row[header] = value;
                  }
                });
                
                // FILTRO: Escludi righe con COMPLETO = "NO"
                const completo = row.COMPLETO || '';
                if (completo.toUpperCase() === 'NO') {
                  console.log('Riga esclusa (COMPLETO=NO):', row.ORDINE);
                  continue;
                }
                
                if (row.ORDINE && row['â‚¬/TON']) {
                  data1.push(row);
                }
              }
              
              console.log('Foglio 1: dati caricati dopo filtro COMPLETO:', data1.length);
              setExcelData(data1);
              
              // Carica Foglio 2 (tariffario trasporti)
              console.log('Caricamento Foglio 2:', FOGLIO2_CSV_URL);
              const response2 = await fetch(FOGLIO2_CSV_URL);
              if (!response2.ok) throw new Error(`HTTP ${response2.status} - Foglio 2`);
              
              const csvText2 = await response2.text();
              console.log('Foglio 2 caricato, primi 500 caratteri:', csvText2.substring(0, 500));
              
              const lines2 = csvText2.split('\n');
              const headers2 = parseCSVLine(lines2[0]);
              console.log('Headers Foglio 2:', headers2);
              
              const data2 = [];
              for (let i = 1; i < lines2.length; i++) {
                if (!lines2[i].trim()) continue;
                
                const values = parseCSVLine(lines2[i]);
                const row = {};
                
                headers2.forEach((header, index) => {
                  let value = values[index] || '';
                  
                  // Rimuovi caratteri non numerici (â‚¬, spazi)
                  let cleanValue = value.replace(/â‚¬/g, '').replace(/\s/g, '').trim();
                  
                  // Gestione formato italiano:
                  if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    // Formato: 1.200,50 â†’ rimuovi punti, converti virgola in punto
                    cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                  } else if (cleanValue.includes(',')) {
                    // Formato: 1200,50 â†’ converti virgola in punto
                    cleanValue = cleanValue.replace(',', '.');
                  } else if (cleanValue.includes('.')) {
                    // Formato ambiguo: 1.200 o 1.2
                    const parts = cleanValue.split('.');
                    if (parts.length === 2 && parts[1].length === 3) {
                      // Es: 1.200 â†’ 1200
                      cleanValue = cleanValue.replace('.', '');
                    }
                  }
                  
                  if (!isNaN(cleanValue) && cleanValue !== '') {
                    row[header] = parseFloat(cleanValue);
                  } else {
                    row[header] = value;
                  }
                });
                
                // Almeno deve avere partenza, arrivo e costo
                if (row['Luogo di Partenza'] && row['Luogo di arrivo'] && row['Costo']) {
                  data2.push(row);
                }
              }
              
              console.log('Foglio 2: tariffario caricato:', data2.length, 'righe');
              if (data2.length > 0) {
                console.log('Prima riga tariffario:', data2[0]);
              }
              setTariffarioData(data2);
              
              // Destinazioni disponibili dal Foglio 1
              const dests = [...new Set(data1.map(r => r.DESTINAZIONE).filter(Boolean))];
              setAvailableDestinations(dests.sort());
              
              // Analizza destinazioni frequenti per suggerimenti Foglio 2
              analyzeSuggestedDestinations(data1, data2);
              
            } catch (error) {
              console.error('ERRORE:', error);
              setDataError(true);
              setErrorMessage(error.message);
            } finally {
              setIsLoading(false);
            }
          };

          // Cache per coordinate per evitare chiamate ripetute
          const coordsCache = {};

          const analyzeSuggestedDestinations = (foglio1Data, foglio2Data) => {
            console.log('=== ANALISI DESTINAZIONI FREQUENTI ===');
            
            // Crea mappa destinazioni nel Foglio 2 (giÃ  nel tariffario)
            const tariffarioSet = new Set(
              (foglio2Data || []).map(t => 
                `${(t['Luogo di arrivo'] || '').trim().toUpperCase()}|${(t['Tipologia'] || '').trim().toUpperCase()}`
              )
            );
            
            // Conta occorrenze per destinazione + modalitÃ 
            const destCounts = {};
            foglio1Data.forEach(order => {
              const dest = order.DESTINAZIONE;
              const modalita = order["MODALITA'"];
              if (!dest || !modalita) return;
              
              const key = `${dest}|${modalita}`;
              if (!destCounts[key]) {
                destCounts[key] = {
                  destinazione: dest,
                  modalita: modalita,
                  count: 0,
                  porti: new Set(),
                  forwarders: new Set(),
                  costiTotali: [],
                  ultimoOrdine: order.ORDINE
                };
              }
              
              destCounts[key].count++;
              if (order.PORTO) destCounts[key].porti.add(order.PORTO);
              if (order.FORWARDER) destCounts[key].forwarders.add(order.FORWARDER);
              
              // Calcola costo totale (costi fissi + inland)
              const totale = (parseFloat(order['FREE OUT'] || 0) +
                             parseFloat(order['DELIVERY ORDER'] || 0) +
                             parseFloat(order['CICLO TERMINAL'] || 0) +
                             parseFloat(order['DOGANA'] || 0) +
                             parseFloat(order['DIRITTO FISSO'] || 0) +
                             parseFloat(order['INLAND'] || 0) +
                             parseFloat(order['FLEGT'] || 0) +
                             parseFloat(order['VISITA MERCE'] || 0) +
                             parseFloat(order['SOSTE'] || 0) +
                             parseFloat(order['SVINCOLO'] || 0));
              
              if (totale > 0) {
                destCounts[key].costiTotali.push(totale);
              }
            });
            
            // Filtra destinazioni con 3+ occorrenze e NON nel tariffario
            const suggestions = Object.values(destCounts)
              .filter(d => {
                const tariffKey = `${d.destinazione.trim().toUpperCase()}|${d.modalita.trim().toUpperCase()}`;
                return d.count >= 3 && !tariffarioSet.has(tariffKey);
              })
              .sort((a, b) => b.count - a.count)
              .slice(0, 10) // Top 10
              .map(d => {
                const avgCosto = d.costiTotali.length > 0
                  ? (d.costiTotali.reduce((a, b) => a + b, 0) / d.costiTotali.length).toFixed(2)
                  : 'N/D';
                
                return {
                  destinazione: d.destinazione,
                  modalita: d.modalita,
                  occorrenze: d.count,
                  portoComune: [...d.porti][0] || 'N/D',
                  forwarderComune: [...d.forwarders][0] || 'N/D',
                  costoMedio: avgCosto
                };
              });
            
            console.log(`Trovate ${suggestions.length} destinazioni frequenti da aggiungere al Foglio 2:`);
            suggestions.forEach((s, i) => {
              console.log(`${i+1}. ${s.destinazione} (${s.modalita}) - ${s.occorrenze}Ã— - Media: â‚¬${s.costoMedio}`);
            });
            
            setSuggestedDestinations(suggestions);
          };

          const getCoordinates = async (address) => {
            // Controlla cache
            if (coordsCache[address]) {
              console.log(`Cache hit per: ${address}`);
              return coordsCache[address];
            }
            
            const normalized = address.toLowerCase().trim();
            
            const cities = {
              // Nord-Ovest
              'milano': { lat: 45.4642, lon: 9.19 },
              'torino': { lat: 45.0703, lon: 7.6869 },
              'genova': { lat: 44.4056, lon: 8.9463 },
              'aosta': { lat: 45.7372, lon: 7.3204 },
              'novara': { lat: 45.4469, lon: 8.6219 },
              'alessandria': { lat: 44.9133, lon: 8.6153 },
              'asti': { lat: 44.9009, lon: 8.2065 },
              'cuneo': { lat: 44.3841, lon: 7.5426 },
              'verbania': { lat: 45.9214, lon: 8.5514 },
              'biella': { lat: 45.5629, lon: 8.0583 },
              'vercelli': { lat: 45.3206, lon: 8.4186 },
              'imperia': { lat: 43.8868, lon: 8.0271 },
              'savona': { lat: 44.3087, lon: 8.4816 },
              'la spezia': { lat: 44.1025, lon: 9.8245 },
              
              // Nord-Est
              'venezia': { lat: 45.4408, lon: 12.3155 },
              'verona': { lat: 45.4384, lon: 10.9916 },
              'padova': { lat: 45.4064, lon: 11.8768 },
              'vicenza': { lat: 45.5455, lon: 11.5354 },
              'treviso': { lat: 45.6669, lon: 12.243 },
              'rovigo': { lat: 45.0703, lon: 11.7897 },
              'belluno': { lat: 46.1386, lon: 12.2153 },
              'trento': { lat: 46.0664, lon: 11.1257 },
              'bolzano': { lat: 46.4983, lon: 11.3548 },
              'trieste': { lat: 45.6495, lon: 13.7768 },
              'udine': { lat: 46.0623, lon: 13.2345 },
              'gorizia': { lat: 45.9411, lon: 13.6222 },
              'pordenone': { lat: 45.9636, lon: 12.6609 },
              
              // Centro-Nord
              'bologna': { lat: 44.4949, lon: 11.3426 },
              'modena': { lat: 44.6471, lon: 10.9252 },
              'parma': { lat: 44.8015, lon: 10.3279 },
              'reggio emilia': { lat: 44.6989, lon: 10.6297 },
              'piacenza': { lat: 45.0526, lon: 9.6924 },
              'ferrara': { lat: 44.8381, lon: 11.6198 },
              'ravenna': { lat: 44.4184, lon: 12.2035 },
              'forli': { lat: 44.2226, lon: 12.0408 },
              'cesena': { lat: 44.1391, lon: 12.2431 },
              'rimini': { lat: 44.0678, lon: 12.5695 },
              
              // Lombardia dettaglio
              'brescia': { lat: 45.5416, lon: 10.2118 },
              'bergamo': { lat: 45.6983, lon: 9.6773 },
              'mantova': { lat: 45.1564, lon: 10.7914 },
              'cremona': { lat: 45.1333, lon: 10.0167 },
              'pavia': { lat: 45.1847, lon: 9.1582 },
              'como': { lat: 45.8081, lon: 9.0852 },
              'varese': { lat: 45.8206, lon: 8.8250 },
              'lecco': { lat: 45.8561, lon: 9.3978 },
              'lodi': { lat: 45.3142, lon: 9.5034 },
              'sondrio': { lat: 46.1699, lon: 9.8782 },
              'monza': { lat: 45.5845, lon: 9.2744 },
              'adro': { lat: 45.6167, lon: 9.9667 },
              'oppeano': { lat: 45.316722, lon: 11.099167 },
              'cornuda': { lat: 45.8333, lon: 12.0167 },
              
              // Toscana
              'firenze': { lat: 43.7696, lon: 11.2558 },
              'prato': { lat: 43.8777, lon: 11.0955 },
              'livorno': { lat: 43.5485, lon: 10.3106 },
              'pisa': { lat: 43.7228, lon: 10.4017 },
              'arezzo': { lat: 43.4632, lon: 11.8796 },
              'siena': { lat: 43.3188, lon: 11.3308 },
              'grosseto': { lat: 42.7634, lon: 11.1139 },
              'lucca': { lat: 43.8376, lon: 10.4950 },
              'pistoia': { lat: 43.9330, lon: 10.9177 },
              'massa': { lat: 44.0366, lon: 10.1411 },
              
              // Centro
              'roma': { lat: 41.9028, lon: 12.4964 },
              'latina': { lat: 41.4677, lon: 12.9036 },
              'frosinone': { lat: 41.6400, lon: 13.3405 },
              'rieti': { lat: 42.4048, lon: 12.8566 },
              'viterbo': { lat: 42.4208, lon: 12.1078 },
              'perugia': { lat: 43.1122, lon: 12.3888 },
              'terni': { lat: 42.5633, lon: 12.5317 },
              'ancona': { lat: 43.6158, lon: 13.5189 },
              'pesaro': { lat: 43.9102, lon: 12.9130 },
              'macerata': { lat: 43.3002, lon: 13.4534 },
              'ascoli piceno': { lat: 42.8533, lon: 13.5759 },
              'fermo': { lat: 43.1605, lon: 13.7185 },
              
              // Lazio dettaglio
              'civitavecchia': { lat: 42.0938, lon: 11.7967 },
              'ariccia': { lat: 41.7292, lon: 12.6719 },
              'albano laziale': { lat: 41.7286, lon: 12.6581 },
              'pomezia': { lat: 41.6694, lon: 12.5019 },
              'santa palomba': { lat: 41.7167, lon: 12.5667 },
              'san cesareo': { lat: 41.8167, lon: 12.8000 },
              'nepi': { lat: 42.2436, lon: 12.3453 },
              
              // Sud
              'napoli': { lat: 40.8518, lon: 14.2681 },
              'salerno': { lat: 40.6824, lon: 14.7681 },
              'caserta': { lat: 41.0732, lon: 14.3328 },
              'benevento': { lat: 41.1297, lon: 14.7826 },
              'avellino': { lat: 40.9145, lon: 14.7906 },
              'bari': { lat: 41.1171, lon: 16.8719 },
              'taranto': { lat: 40.4738, lon: 17.2405 },
              'foggia': { lat: 41.4621, lon: 15.5447 },
              'lecce': { lat: 40.3515, lon: 18.1750 },
              'brindisi': { lat: 40.6327, lon: 17.9419 },
              'barletta': { lat: 41.3208, lon: 16.2819 },
              'potenza': { lat: 40.6389, lon: 15.8056 },
              'matera': { lat: 40.6664, lon: 16.6043 },
              'cosenza': { lat: 39.2979, lon: 16.2523 },
              'catanzaro': { lat: 38.9098, lon: 16.5877 },
              'reggio calabria': { lat: 38.1113, lon: 15.6476 },
              'crotone': { lat: 39.0808, lon: 17.1250 },
              'vibo valentia': { lat: 38.6756, lon: 16.1008 },
              
              // Campania dettaglio
              'aversa': { lat: 40.9732, lon: 14.2064 },
              'castellammare di stabia': { lat: 40.7017, lon: 14.4847 },
              'torre del greco': { lat: 40.7881, lon: 14.3686 },
              'pozzuoli': { lat: 40.8241, lon: 14.1231 },
              'giugliano': { lat: 40.9283, lon: 14.1942 },
              'afragola': { lat: 40.9238, lon: 14.3106 },
              'cellole': { lat: 41.1147, lon: 13.9286 },
              'isola del liri': { lat: 41.6808, lon: 13.5764 },
              'villa santa lucia': { lat: 41.4697, lon: 13.7730 },
              'villa s.lucia': { lat: 41.4697, lon: 13.7730 },
              'villa s lucia': { lat: 41.4697, lon: 13.7730 },
              'roccapiemonte': { lat: 40.7619, lon: 14.6908 },
              'ausonia': { lat: 41.3364, lon: 13.7300 },
              
              // Sicilia
              'palermo': { lat: 38.1157, lon: 13.3615 },
              'catania': { lat: 37.5079, lon: 15.0830 },
              'messina': { lat: 38.1938, lon: 15.5540 },
              'siracusa': { lat: 37.0755, lon: 15.2866 },
              'trapani': { lat: 38.0176, lon: 12.5365 },
              'agrigento': { lat: 37.3110, lon: 13.5765 },
              'ragusa': { lat: 36.9269, lon: 14.7256 },
              'caltanissetta': { lat: 37.4908, lon: 14.0622 },
              'enna': { lat: 37.5671, lon: 14.2793 },
              
              // Sardegna
              'cagliari': { lat: 39.2238, lon: 9.1217 },
              'sassari': { lat: 40.7259, lon: 8.5594 },
              'nuoro': { lat: 40.3210, lon: 9.3301 },
              'oristano': { lat: 39.9042, lon: 8.5914 },
              'olbia': { lat: 40.9237, lon: 9.4966 }
            };
            
            for (const [city, coords] of Object.entries(cities)) {
              if (normalized.includes(city)) {
                coordsCache[address] = coords;
                return coords;
              }
            }

            try {
              // Timeout ridotto a 2 secondi per geocoding
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 2000);
              
              const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}, Italy&limit=1`,
                { 
                  headers: { 'User-Agent': 'LogisticsCostCalculator/1.0' },
                  signal: controller.signal
                }
              );
              
              clearTimeout(timeoutId);
              
              const data = await response.json();
              if (data && data.length > 0) {
                const coords = {
                  lat: Number(Number(data[0].lat).toFixed(6)),
                  lon: Number(Number(data[0].lon).toFixed(6))
                };
                coordsCache[address] = coords;
                console.log(`Geocoded "${address}":`, coords);
                return coords;
              }
            } catch (error) {
              if (error.name === 'AbortError') {
                console.warn(`Geocoding timeout per ${address}`);
              } else {
                console.error('Geocoding error:', error);
              }
            }
            return null;
          };

          const calculateDistance = async (c1, c2) => {
            try {
              // OSRM con timeout di 3 secondi per evitare attese infinite
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              const url = `https://router.project-osrm.org/route/v1/driving/${c1.lon},${c1.lat};${c2.lon},${c2.lat}?overview=false`;
              const response = await fetch(url, { signal: controller.signal });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) {
                throw new Error('OSRM API error');
              }
              
              const data = await response.json();
              
              if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const distanceKm = data.routes[0].distance / 1000;
                return distanceKm;
              } else {
                console.warn('OSRM fallito, uso Haversine');
                return calculateDistanceHaversine(c1, c2);
              }
            } catch (error) {
              if (error.name === 'AbortError') {
                console.warn('OSRM timeout, uso Haversine');
              } else {
                console.error('Errore OSRM:', error);
              }
              return calculateDistanceHaversine(c1, c2);
            }
          };
          
          const calculateDistanceHaversine = (c1, c2) => {
            const R = 6371;
            const dLat = (c2.lat - c1.lat) * Math.PI / 180;
            const dLon = (c2.lon - c1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(c1.lat * Math.PI / 180) * Math.cos(c2.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
          };

          const calculateBestOption = async () => {
            if (!destinazione || !modalita || !tonnellate) {
              alert('Compila tutti i campi');
              return;
            }
            
            setIsCalculating(true);
            
            try {
              console.log('=== INIZIO CALCOLO ===');
              console.log('ModalitÃ  richiesta:', modalita);
              console.log('Destinazione richiesta:', destinazione);
              console.log('Totale ordini disponibili (Foglio 1):', excelData.length);
              
              const filtered = excelData.filter(r => {
                const modalitaRow = r["MODALITA'"];
                const hasEuroTon = r['â‚¬/TON'];
                return modalitaRow === modalita && hasEuroTon;
              });
              
              console.log('Ordini filtrati per modalitÃ  "' + modalita + '":', filtered.length);
              
              if (filtered.length === 0) {
                alert('Nessun ordine per questa modalitÃ ');
                setIsCalculating(false);
                return;
              }
              
              // Cerca match esatto nella destinazione
              const exact = filtered.filter(r => r.DESTINAZIONE === destinazione);
              
              let ordersToUse = [];
              let isEstimated = false;
              let referenceDestinations = [];
              let useTariffario = false;
              let tariffarioMatch = null;
              
              if (exact.length > 0) {
                // Match esatto trovato nel Foglio 1
                console.log('âœ“ Match esatto trovato nel Foglio 1');
                ordersToUse = exact;
              } else {
                // Nessun match esatto: cerca nel tariffario (Foglio 2)
                console.log('âš ï¸ Nessun match esatto, cerco nel tariffario...');
                
                if (tariffarioData && tariffarioData.length > 0) {
                  console.log('=== RICERCA NEL TARIFFARIO ===');
                  console.log('Destinazione cercata:', destinazione);
                  console.log('ModalitÃ  cercata:', modalita);
                  console.log('Totale righe tariffario:', tariffarioData.length);
                  console.log('Prima riga tariffario (esempio):', tariffarioData[0]);
                  console.log('Nomi colonne disponibili:', Object.keys(tariffarioData[0]));
                  
                  // Cerca nel tariffario una corrispondenza di destinazione e tipologia
                  const tariffarioFiltered = tariffarioData.filter(t => {
                    const arrivo = t['Luogo di arrivo'] || '';
                    const tipologia = t['Tipologia'] || '';
                    
                    console.log('Controllo riga:', {
                      arrivo: arrivo,
                      tipologia: tipologia,
                      arrivoMatch: arrivo.toLowerCase().trim() === destinazione.toLowerCase().trim(),
                      tipologiaMatch: tipologia.toUpperCase() === modalita.toUpperCase()
                    });
                    
                    // Normalizza confronto (case-insensitive, trim)
                    const arrivoMatch = arrivo.toLowerCase().trim() === destinazione.toLowerCase().trim();
                    const tipologiaMatch = tipologia.toUpperCase() === modalita.toUpperCase();
                    
                    return arrivoMatch && tipologiaMatch;
                  });
                  
                  console.log('Tariffario: trovate', tariffarioFiltered.length, 'corrispondenze');
                  
                  if (tariffarioFiltered.length > 0) {
                    // Usa il tariffario
                    useTariffario = true;
                    tariffarioMatch = tariffarioFiltered[0]; // Prendi la prima corrispondenza
                    console.log('âœ“ Uso tariffario:', tariffarioMatch);
                  }
                }
                
                if (!useTariffario) {
                  // Fallback: stima basata su destinazioni vicine (logica originale)
                  console.log('âš ï¸ Nessun match nel tariffario, stimo da destinazioni vicine...');
                  console.log('ðŸ’¡ SUGGERIMENTO: Aggiungi questa destinazione al Foglio 2 (tariffario) per calcoli istantanei!');
                  isEstimated = true;
                  const targetCoords = await getCoordinates(destinazione);
                  
                  if (!targetCoords) {
                    alert('Impossibile trovare la destinazione');
                    setIsCalculating(false);
                    return;
                  }
                  
                  console.log(`Calcolo distanze da tutte le ${filtered.length} destinazioni...`);
                  
                  // USA TUTTE le destinazioni TRUCK disponibili per trovare la migliore
                  const samplesToCheck = filtered;
                  const destsWithDist = [];
                  
                  // PARALLELO: Calcola tutte le coordinate insieme
                  const coordsPromises = samplesToCheck.map(row => getCoordinates(row.DESTINAZIONE));
                  const allCoords = await Promise.all(coordsPromises);
                  
                  // PARALLELO: Calcola tutte le distanze insieme (invece di una alla volta)
                  const distancePromises = allCoords.map((coords, idx) => {
                    if (coords) {
                      return calculateDistance(targetCoords, coords).then(distance => ({
                        destination: samplesToCheck[idx].DESTINAZIONE,
                        distance: distance
                      }));
                    }
                    return null;
                  });
                  
                  const results = await Promise.all(distancePromises);
                  
                  results.forEach(result => {
                    if (result) {
                      destsWithDist.push(result);
                      console.log(`âœ“ ${result.destination}: ${result.distance.toFixed(0)}km`);
                    }
                  });
                  
                  destsWithDist.sort((a, b) => a.distance - b.distance);
                  const nearest = destsWithDist.slice(0, 3); // Top 3 piÃ¹ vicine
                  referenceDestinations = nearest;
                  
                  console.log('Destinazioni piÃ¹ vicine trovate:');
                  nearest.forEach((d, i) => {
                    console.log(`${i+1}. ${d.destination}: ${d.distance.toFixed(0)}km`);
                  });
                  
                  nearest.forEach(nd => {
                    const orders = filtered.filter(r => r.DESTINAZIONE === nd.destination);
                    ordersToUse.push(...orders);
                  });
                }
              }
              
              const ton = parseFloat(tonnellate);
              
              // Se usiamo il tariffario, calcolo ibrido: INLAND dal Foglio 2 + costi fissi medi dal Foglio 1
              if (useTariffario) {
                console.log('=== USO TARIFFARIO (SOLO INLAND) ===');
                console.log('Riga tariffario trovata:', tariffarioMatch);
                
                const inlandTariffario = parseFloat(tariffarioMatch['Costo']);
                const partner = tariffarioMatch['Partner'] || 'N/D';
                const porto = tariffarioMatch['Luogo di Partenza'] || 'N/D';
                
                console.log('INLAND da tariffario:', inlandTariffario);
                
                // Calcola costi fissi medi dal Foglio 1 per questa modalitÃ  e porto
                const ordersForAvg = excelData.filter(order => 
                  order["MODALITA'"] === modalita && 
                  order.PORTO === porto.toUpperCase() &&
                  order['â‚¬/TON']
                );
                
                let avgCostiFissiPerTon = 0;
                if (ordersForAvg.length > 0) {
                  console.log(`Calcolo costi fissi medi da ${ordersForAvg.length} ordini ${modalita} da ${porto}`);
                  
                  let totalCostiFissiPerTon = 0;
                  let count = 0;
                  
                  ordersForAvg.forEach(order => {
                    const tons = parseFloat(order.TON || 0);
                    if (tons <= 0) return;
                    
                    const freeOut = parseFloat(order['FREE OUT'] || 0);
                    const deliveryOrder = parseFloat(order['DELIVERY ORDER'] || 0);
                    const cicloTerminal = parseFloat(order['CICLO TERMINAL'] || 0);
                    const dogana = parseFloat(order['DOGANA'] || 0);
                    const dirittoFisso = parseFloat(order['DIRITTO FISSO'] || 0);
                    const flegt = parseFloat(order['FLEGT'] || 0);
                    const visitaMerce = parseFloat(order['VISITA MERCE'] || 0);
                    const soste = parseFloat(order['SOSTE'] || 0);
                    const svincolo = parseFloat(order['SVINCOLO'] || 0);
                    
                    const costiFissiTotali = freeOut + deliveryOrder + cicloTerminal + dogana + 
                                           dirittoFisso + flegt + visitaMerce + soste + svincolo;
                    
                    totalCostiFissiPerTon += (costiFissiTotali / tons);
                    count++;
                  });
                  
                  avgCostiFissiPerTon = totalCostiFissiPerTon / count;
                  console.log('Costi fissi medi:', avgCostiFissiPerTon.toFixed(2), 'â‚¬/ton');
                } else {
                  // Fallback: usa media generale per la modalitÃ 
                  const allOrdersMode = excelData.filter(o => o["MODALITA'"] === modalita && o['â‚¬/TON']);
                  if (allOrdersMode.length > 0) {
                    let total = 0;
                    let count = 0;
                    allOrdersMode.forEach(order => {
                      const tons = parseFloat(order.TON || 0);
                      if (tons <= 0) return;
                      const euroTon = parseFloat(order['â‚¬/TON'] || 0);
                      const inland = parseFloat(order['INLAND'] || 0);
                      const costiFissiPerTon = euroTon - (inland / tons);
                      if (costiFissiPerTon > 0) {
                        total += costiFissiPerTon;
                        count++;
                      }
                    });
                    avgCostiFissiPerTon = count > 0 ? total / count : 30; // default 30â‚¬/ton
                  } else {
                    avgCostiFissiPerTon = 30; // Default generico
                  }
                  console.log('Costi fissi stimati (nessun ordine da questo porto):', avgCostiFissiPerTon.toFixed(2), 'â‚¬/ton');
                }
                
                const inlandPerTon = inlandTariffario / ton;
                const costoTotalePerTon = avgCostiFissiPerTon + inlandPerTon;
                
                console.log('=== RIEPILOGO TARIFFARIO ===');
                console.log(`Costi fissi: â‚¬${avgCostiFissiPerTon.toFixed(2)}/ton Ã— ${ton} = â‚¬${(avgCostiFissiPerTon * ton).toFixed(2)}`);
                console.log(`INLAND: â‚¬${inlandPerTon.toFixed(2)}/ton Ã— ${ton} = â‚¬${inlandTariffario.toFixed(2)}`);
                console.log(`TOTALE: â‚¬${(costoTotalePerTon * ton).toFixed(2)}`);
                
                setRisultato({
                  porto: porto,
                  forwarder: partner,
                  costiFissi: (avgCostiFissiPerTon * ton).toFixed(2),
                  inland: inlandTariffario.toFixed(2),
                  costoTotale: (costoTotalePerTon * ton).toFixed(2),
                  costoPerTon: costoTotalePerTon.toFixed(2),
                  tonnellate: ton,
                  numOrdiniStorici: ordersForAvg.length,
                  isEstimated: false,
                  isTariffario: true,
                  referenceDestinations: []
                });
                
                setIsCalculating(false);
                return;
              }
              
              // Altrimenti, logica originale con ordini storici
              if (ordersToUse.length === 0) {
                alert('Nessun ordine trovato');
                setIsCalculating(false);
                return;
              }
              
              const combinations = {};
              console.log('=== CREAZIONE COMBINAZIONI ===');
              console.log('Numero ordini da processare:', ordersToUse.length);
              ordersToUse.forEach((order, idx) => {
                console.log(`Ordine ${idx + 1}:`, {
                  ordine: order.ORDINE,
                  porto: order.PORTO,
                  forwarder: order.FORWARDER,
                  euroTon: order['â‚¬/TON'],
                  destinazione: order.DESTINAZIONE
                });
                
                const key = `${order.PORTO}|${order.FORWARDER}`;
                console.log(`  Key creata: "${key}"`);
                
                if (!combinations[key]) {
                  combinations[key] = { 
                    porto: order.PORTO, 
                    forwarder: order.FORWARDER, 
                    costs: [],
                    destinations: []
                  };
                  console.log(`  âœ“ Nuova combinazione creata`);
                }
                combinations[key].costs.push(parseFloat(order['â‚¬/TON']));
                if (!combinations[key].destinations.includes(order.DESTINAZIONE)) {
                  combinations[key].destinations.push(order.DESTINAZIONE);
                }
              });
              
              console.log('Totale combinazioni create:', Object.keys(combinations).length);
              console.log('Combinazioni:', Object.keys(combinations));
              
              // Verifica che ci siano combinazioni valide
              if (Object.keys(combinations).length === 0) {
                alert('Nessuna combinazione porto/forwarder trovata');
                setIsCalculating(false);
                return;
              }
              
              const portCoords = {
                'VENEZIA': { lat: 45.4408, lon: 12.3155 },
                'TRIESTE': { lat: 45.6495, lon: 13.7768 },
                'GENOVA': { lat: 44.4056, lon: 8.9463 },
                'LIVORNO': { lat: 43.5485, lon: 10.3106 },
                'RAVENNA': { lat: 44.4184, lon: 12.2035 },
                'NAPOLI': { lat: 40.8518, lon: 14.2681 },
                'SALERNO': { lat: 40.6824, lon: 14.7681 },
                'CIVITAVECCHIA': { lat: 42.0938, lon: 11.7967 }
              };
              
              let bestOption = null;
              let lowestCost = Infinity;
              
              if (isEstimated) {
                const targetCoords = await getCoordinates(destinazione);
                console.log('=== CALCOLO DISTANZE PORTI ===');
                
                // PARALLELO: Calcola distanze di tutti i porti insieme
                const portDistancePromises = Object.values(combinations).map(async (combo) => {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  const portCoord = portCoords[combo.porto.toUpperCase()];
                  
                  if (portCoord && targetCoords) {
                    const distance = await calculateDistance(targetCoords, portCoord);
                    console.log(`Porto ${combo.porto}:`, {
                      distanza_km: distance.toFixed(1),
                      costo_medio: avgCost.toFixed(2)
                    });
                    
                    return {
                      ...combo,
                      avgCost,
                      numOrders: combo.costs.length,
                      portDistance: distance
                    };
                  }
                  return null;
                });
                
                const combosWithDistance = (await Promise.all(portDistancePromises)).filter(Boolean);
                
                // Per le STIME: ordina SOLO per distanza porto (il costo Ã¨ meno importante)
                combosWithDistance.sort((a, b) => a.portDistance - b.portDistance);
                
                console.log('--- Porti ordinati per distanza ---');
                combosWithDistance.forEach((c, i) => {
                  console.log(`${i+1}. ${c.porto} - ${c.portDistance.toFixed(0)}km - â‚¬${c.avgCost.toFixed(2)}/ton`);
                });
                
                if (combosWithDistance.length > 0) {
                  bestOption = combosWithDistance[0];
                  console.log('âœ“ PORTO SCELTO:', bestOption.porto, '-', bestOption.portDistance.toFixed(0), 'km');
                } else {
                  alert('Impossibile calcolare la distanza dai porti');
                  setIsCalculating(false);
                  return;
                }
                
              } else {
                Object.values(combinations).forEach(combo => {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  if (avgCost < lowestCost) {
                    lowestCost = avgCost;
                    bestOption = { ...combo, avgCost, numOrders: combo.costs.length };
                  }
                });
              }
              
              // Verifica finale che bestOption sia stato trovato
              if (!bestOption) {
                alert('Impossibile determinare la migliore opzione');
                setIsCalculating(false);
                return;
              }
              
              const ordersForChosen = ordersToUse.filter(order => 
                order.PORTO === bestOption.porto && 
                order.FORWARDER === bestOption.forwarder
              );
              
              console.log('Ordini per porto+forwarder scelto:', ordersForChosen.length);
              
              // Calcola costi PER TONNELLATA (non totali!)
              let totalCostiFissiPerTon = 0;
              let totalInlandPerTon = 0;
              let totalOrders = 0;
              
              ordersForChosen.forEach((order, idx) => {
                const tons = parseFloat(order.TON || 0);
                if (tons <= 0) {
                  console.log(`Ordine ${order.ORDINE} saltato: tonnellate = ${tons}`);
                  return;
                }
                
                const freeOut = parseFloat(order['FREE OUT'] || 0);
                const deliveryOrder = parseFloat(order['DELIVERY ORDER'] || 0);
                const cicloTerminal = parseFloat(order['CICLO TERMINAL'] || 0);
                const dogana = parseFloat(order['DOGANA'] || 0);
                const dirittoFisso = parseFloat(order['DIRITTO FISSO'] || 0);
                const flegt = parseFloat(order['FLEGT'] || 0);
                const visitaMerce = parseFloat(order['VISITA MERCE'] || 0);
                const soste = parseFloat(order['SOSTE'] || 0);
                const svincolo = parseFloat(order['SVINCOLO'] || 0);
                const inland = parseFloat(order['INLAND'] || 0);
                
                const costiFissiTotali = freeOut + deliveryOrder + cicloTerminal + dogana + 
                                   dirittoFisso + flegt + visitaMerce + soste + svincolo;
                
                // NORMALIZZA per tonnellata
                const costiFissiPerTon = costiFissiTotali / tons;
                const inlandPerTon = inland / tons;
                
                console.log(`Ordine ${idx+1} (${order.ORDINE}) - ${tons} ton`);
                console.log(`  Costi fissi: â‚¬${costiFissiTotali.toFixed(2)} â†’ â‚¬${costiFissiPerTon.toFixed(2)}/ton`);
                console.log(`  INLAND: â‚¬${inland.toFixed(2)} â†’ â‚¬${inlandPerTon.toFixed(2)}/ton`);
                
                totalCostiFissiPerTon += costiFissiPerTon;
                totalInlandPerTon += inlandPerTon;
                totalOrders++;
              });
              
              const avgCostiFissiPerTon = totalCostiFissiPerTon / totalOrders;
              const avgInlandPerTon = totalInlandPerTon / totalOrders;
              
              console.log('--- MEDIE PER TONNELLATA ---');
              console.log('MEDIA Costi Fissi:', avgCostiFissiPerTon.toFixed(2), 'â‚¬/ton');
              console.log('MEDIA INLAND:', avgInlandPerTon.toFixed(2), 'â‚¬/ton');
              
              // Ora moltiplica per le tonnellate richieste
              // ton giÃ  dichiarato all'inizio
              const costiFissiTotali = avgCostiFissiPerTon * ton;
              const inlandTotale = avgInlandPerTon * ton;
              
              let adjustedInlandPerTon = avgInlandPerTon;
              if (isEstimated && referenceDestinations.length > 0) {
                const targetCoords = await getCoordinates(destinazione);
                
                let avgPortDistToRef = 0;
                let countDistances = 0;
                
                for (const order of ordersForChosen) {
                  const refCoords = await getCoordinates(order.DESTINAZIONE);
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (refCoords && portCoord) {
                    const dist = await calculateDistance(portCoord, refCoords);
                    avgPortDistToRef += dist;
                    countDistances++;
                  }
                }
                
                if (countDistances > 0) {
                  avgPortDistToRef = avgPortDistToRef / countDistances;
                  
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (portCoord && targetCoords) {
                    const portDistToTarget = await calculateDistance(portCoord, targetCoords);
                    const distanceRatio = portDistToTarget / avgPortDistToRef;
                    adjustedInlandPerTon = avgInlandPerTon * distanceRatio;
                    
                    console.log('=== STIMA INLAND ===');
                    console.log('INLAND medio storico:', avgInlandPerTon.toFixed(2), 'â‚¬/ton');
                    console.log('Distanza media portoâ†’destinazioni storiche:', avgPortDistToRef.toFixed(0), 'km');
                    console.log('Distanza portoâ†’target:', portDistToTarget.toFixed(0), 'km');
                    console.log('INLAND stimato:', adjustedInlandPerTon.toFixed(2), 'â‚¬/ton');
                  }
                }
              }
              
              // Ricalcola i totali con l'INLAND aggiustato
              const finalCostiFissi = avgCostiFissiPerTon * ton;
              const finalInland = adjustedInlandPerTon * ton;
              const costoTotale = finalCostiFissi + finalInland;
              
              console.log('=== CALCOLO FINALE ===');
              console.log(`Per ${ton} tonnellate:`);
              console.log(`Costi Fissi: â‚¬${avgCostiFissiPerTon.toFixed(2)}/ton Ã— ${ton} = â‚¬${finalCostiFissi.toFixed(2)}`);
              console.log(`INLAND: â‚¬${adjustedInlandPerTon.toFixed(2)}/ton Ã— ${ton} = â‚¬${finalInland.toFixed(2)}`);
              console.log(`TOTALE: â‚¬${costoTotale.toFixed(2)}`);
              
              setRisultato({
                porto: bestOption.porto,
                forwarder: bestOption.forwarder,
                costiFissi: finalCostiFissi.toFixed(2),
                inland: finalInland.toFixed(2),
                costoTotale: costoTotale.toFixed(2),
                costoPerTon: (costoTotale / ton).toFixed(2),
                tonnellate: ton,
                numOrdiniStorici: bestOption.numOrders,
                isEstimated: isEstimated,
                isTariffario: false,
                referenceDestinations: referenceDestinations
              });
              
            } catch (error) {
              console.error('Errore calcolo:', error);
              alert('Errore nel calcolo');
            } finally {
              setIsCalculating(false);
            }
          };

          if (isLoading) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                <div className="text-center">
                  <Loader />
                  <p className="text-gray-600 text-lg mt-4">Caricamento dati...</p>
                </div>
              </div>
            );
          }

          if (dataError) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md">
                  <AlertCircle />
                  <h2 className="text-xl font-bold mb-4">Errore Caricamento</h2>
                  <p className="text-gray-600 mb-4">Impossibile caricare i dati.</p>
                  <div className="bg-red-50 p-3 rounded mb-4">
                    <p className="text-sm text-red-800">{errorMessage}</p>
                  </div>
                  <p className="text-sm text-gray-600 mb-4">Apri Console (F12) per dettagli.</p>
                  <button onClick={loadData} className="w-full bg-indigo-600 text-white py-3 rounded-lg">Riprova</button>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
              <div className="max-w-3xl mx-auto">
                <div className="bg-white rounded-2xl shadow-xl p-8 mb-6">
                  <div className="flex items-center gap-3 mb-6">
                    <Package />
                    <h1 className="text-3xl font-bold text-gray-800">Calcolo Costi Logistici</h1>
                  </div>

                  <div className="bg-green-50 border-l-4 border-green-500 p-4 mb-6">
                    <p className="text-sm text-green-800">
                      <strong>âœ“ Connesso</strong>
                    </p>
                    <p className="text-xs text-green-700 mt-1">
                      Foglio 1: {excelData.length} ordini â€¢ Foglio 2: {tariffarioData ? tariffarioData.length : 0} tariffe
                    </p>
                  </div>

                  {suggestedDestinations.length > 0 && (
                    <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                      <div className="flex items-center justify-between mb-2">
                        <p className="text-sm font-semibold text-blue-800">
                          ðŸ’¡ Suggerimenti Tariffario
                        </p>
                        <button
                          onClick={() => setSuggestedDestinations([])}
                          className="text-xs text-blue-600 hover:text-blue-800"
                        >
                          Nascondi
                        </button>
                      </div>
                      <p className="text-xs text-blue-700 mb-3">
                        Queste destinazioni compaiono spesso (3+). Aggiungile al Foglio 2 per calcoli istantanei:
                      </p>
                      <div className="bg-white rounded p-3 max-h-60 overflow-y-auto">
                        <table className="w-full text-xs">
                          <thead>
                            <tr className="border-b">
                              <th className="text-left py-1 pr-2">Destinazione</th>
                              <th className="text-left py-1 px-2">Tipo</th>
                              <th className="text-center py-1 px-2">Ã—</th>
                              <th className="text-left py-1 px-2">Porto</th>
                              <th className="text-right py-1 pl-2">Costo Medio</th>
                            </tr>
                          </thead>
                          <tbody>
                            {suggestedDestinations.map((s, i) => (
                              <tr key={i} className="border-b hover:bg-gray-50">
                                <td className="py-2 pr-2 text-gray-800">{s.destinazione}</td>
                                <td className="py-2 px-2 text-gray-600">{s.modalita}</td>
                                <td className="py-2 px-2 text-center font-semibold text-blue-600">{s.occorrenze}</td>
                                <td className="py-2 px-2 text-gray-600">{s.portoComune}</td>
                                <td className="py-2 pl-2 text-right font-semibold text-green-700">â‚¬{s.costoMedio}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                      <p className="text-xs text-blue-600 mt-2">
                        ðŸ“‹ Copia questi valori nel Foglio 2: Porto | Destinazione | Tipo | Costo | Partner
                      </p>
                    </div>
                  )}

                  <div className="space-y-6">
                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <MapPin />
                        Destinazione
                      </label>
                      <input
                        type="text"
                        value={destinazione}
                        onChange={(e) => setDestinazione(e.target.value)}
                        placeholder="es. Milano"
                        list="dests"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                      <datalist id="dests">
                        {availableDestinations.map(d => <option key={d} value={d} />)}
                      </datalist>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <Truck />
                        ModalitÃ 
                      </label>
                      <select value={modalita} onChange={(e) => setModalita(e.target.value)} className="w-full px-4 py-3 border rounded-lg">
                        <option value="">Seleziona...</option>
                        <option value="CONTAINER">Container</option>
                        <option value="TRUCK">Camion</option>
                      </select>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold">Tonnellate</label>
                      <input
                        type="number"
                        value={tonnellate}
                        onChange={(e) => setTonnellate(e.target.value)}
                        placeholder="es. 25"
                        step="0.01"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                    </div>

                    <button
                      onClick={calculateBestOption}
                      disabled={isCalculating}
                      className="w-full bg-indigo-600 text-white font-bold py-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-400"
                    >
                      <Calculator />
                      {isCalculating ? 'Calcolo...' : 'Calcola Preventivo'}
                    </button>
                  </div>
                </div>

                {risultato && (
                  <div className="bg-white rounded-2xl shadow-xl p-8">
                    {risultato.isTariffario && (
                      <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                        <p className="text-sm text-blue-800">
                          <strong>ðŸ“‹ Tariffario</strong> - Costo da tariffario trasporti
                        </p>
                      </div>
                    )}
                    
                    {risultato.isEstimated && !risultato.isTariffario && (
                      <div className="bg-amber-50 border-l-4 border-amber-500 p-4 mb-6">
                        <p className="text-sm text-amber-800">
                          <strong>âš ï¸ Stima</strong> - Basata su {risultato.referenceDestinations.length} destinazioni vicine
                        </p>
                      </div>
                    )}

                    <div className="flex items-center gap-3 mb-6">
                      <TrendingDown />
                      <h2 className="text-2xl font-bold">Preventivo</h2>
                    </div>

                    <div className="grid md:grid-cols-2 gap-4 mb-6">
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">{risultato.isTariffario ? 'Partenza' : 'Porto'}</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.porto}</p>
                      </div>
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">{risultato.isTariffario ? 'Partner' : 'Forwarder'}</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.forwarder}</p>
                      </div>
                    </div>

                    <div className="bg-green-50 p-6 rounded-xl mb-6">
                      <h3 className="font-semibold text-gray-700 mb-4">Riepilogo Costi</h3>
                      <div className="space-y-3">
                        {!risultato.isTariffario && (
                          <div className="flex justify-between items-center">
                            <span className="text-sm text-gray-600">Costi Fissi (porto + dogana + servizi)</span>
                            <span className="text-lg font-bold text-gray-800">â‚¬{risultato.costiFissi}</span>
                          </div>
                        )}
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">
                            {risultato.isTariffario ? 'Costo Trasporto' : `Inland (trasporto ${risultato.porto} â†’ destinazione)`}
                          </span>
                          <span className="text-lg font-bold text-gray-800">â‚¬{risultato.inland}</span>
                        </div>
                        <div className="border-t-2 border-green-200 pt-3 mt-3">
                          <div className="flex justify-between items-center">
                            <span className="text-base font-semibold text-gray-700">Costo Totale</span>
                            <span className="text-2xl font-bold text-green-700">â‚¬{risultato.costoTotale}</span>
                          </div>
                          <div className="flex justify-between items-center mt-2">
                            <span className="text-sm text-gray-600">Costo per Tonnellata</span>
                            <span className="text-lg font-bold text-green-700">â‚¬{risultato.costoPerTon}/ton</span>
                          </div>
                          <p className="text-xs text-gray-500 mt-2">
                            ({risultato.tonnellate} tonnellate)
                          </p>
                        </div>
                      </div>
                    </div>

                    {!risultato.isTariffario && risultato.numOrdiniStorici > 0 && (
                      <p className="text-sm text-gray-500 mt-4">Basato su {risultato.numOrdiniStorici} ordini storici</p>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
