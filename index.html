<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcolo Costi Logistici</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const Calculator = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/></svg>;
        const TrendingDown = () => <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 18 13.5 8.5 8.5 13.5 1 6"/><polyline points="17 18 23 18 23 12"/></svg>;
        const Package = () => <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>;
        const Truck = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="1" y="3" width="15" height="13"/><circle cx="5.5" cy="18.5" r="2.5"/></svg>;
        const MapPin = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>;
        const AlertCircle = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/></svg>;
        const Loader = () => <svg className="animate-spin" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/></svg>;

        const App = () => {
          const [excelData, setExcelData] = useState(null);
          const [tariffarioData, setTariffarioData] = useState(null);
          const [destinazione, setDestinazione] = useState('');
          const [modalita, setModalita] = useState('');
          const [tonnellate, setTonnellate] = useState('');
          const [risultato, setRisultato] = useState(null);
          const [availableDestinations, setAvailableDestinations] = useState([]);
          const [suggestedDestinations, setSuggestedDestinations] = useState([]);
          const [isCalculating, setIsCalculating] = useState(false);
          const [isLoading, setIsLoading] = useState(true);
          const [dataError, setDataError] = useState(false);
          const [errorMessage, setErrorMessage] = useState('');

          // URL per i due fogli
          const FOGLIO1_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-MthW0ItRfSSthoga_Tvd7w1_OMdDXZylZQhLjG5I0bk1cEGZjqPsFUt6I373L4oFpw156lvbvYHJ/pub?gid=0&single=true&output=csv';
          const FOGLIO2_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vR-MthW0ItRfSSthoga_Tvd7w1_OMdDXZylZQhLjG5I0bk1cEGZjqPsFUt6I373L4oFpw156lvbvYHJ/pub?gid=738284096&single=true&output=csv';

          useEffect(() => {
            loadData();
          }, []);

          const parseCSVLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
            return result;
          };

          const loadData = async () => {
            try {
              setIsLoading(true);
              setDataError(false);
              
              // Carica Foglio 1 (consuntivi)
              console.log('Caricamento Foglio 1:', FOGLIO1_CSV_URL);
              const response1 = await fetch(FOGLIO1_CSV_URL);
              if (!response1.ok) throw new Error(`HTTP ${response1.status} - Foglio 1`);
              
              const csvText1 = await response1.text();
              console.log('Foglio 1 caricato, primi 500 caratteri:', csvText1.substring(0, 500));
              
              const lines1 = csvText1.split('\n');
              const headers1 = parseCSVLine(lines1[0]);
              console.log('Headers Foglio 1:', headers1);
              
              const data1 = [];
              for (let i = 1; i < lines1.length; i++) {
                if (!lines1[i].trim()) continue;
                
                const values = parseCSVLine(lines1[i]);
                const row = {};
                
                headers1.forEach((header, index) => {
                  let value = values[index] || '';
                  
                  // Rimuovi caratteri non numerici (‚Ç¨, spazi)
                  let cleanValue = value.replace(/‚Ç¨/g, '').replace(/\s/g, '').trim();
                  
                  // Gestione formato italiano:
                  // Se contiene sia punto che virgola: 1.200,50 ‚Üí punto √® separatore migliaia
                  // Se contiene solo virgola: 1200,50 ‚Üí virgola √® decimale
                  // Se contiene solo punto: potrebbe essere 1.200 (migliaia) o 1.2 (decimale)
                  
                  if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    // Formato: 1.200,50 ‚Üí rimuovi punti, converti virgola in punto
                    cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                  } else if (cleanValue.includes(',')) {
                    // Formato: 1200,50 ‚Üí converti virgola in punto
                    cleanValue = cleanValue.replace(',', '.');
                  } else if (cleanValue.includes('.')) {
                    // Formato ambiguo: 1.200 o 1.2
                    // Se ci sono 3 cifre dopo il punto, √® separatore migliaia
                    const parts = cleanValue.split('.');
                    if (parts.length === 2 && parts[1].length === 3) {
                      // Es: 1.200 ‚Üí 1200
                      cleanValue = cleanValue.replace('.', '');
                    }
                    // Altrimenti lascia il punto come decimale
                  }
                  
                  if (!isNaN(cleanValue) && cleanValue !== '') {
                    row[header] = parseFloat(cleanValue);
                  } else {
                    row[header] = value;
                  }
                });
                
                // FILTRO: Escludi righe con COMPLETO = "NO"
                const completo = row.COMPLETO || '';
                if (completo.toUpperCase() === 'NO') {
                  console.log('Riga esclusa (COMPLETO=NO):', row.ORDINE);
                  continue;
                }
                
                if (row.ORDINE && row['‚Ç¨/TON']) {
                  data1.push(row);
                }
              }
              
              console.log('Foglio 1: dati caricati dopo filtro COMPLETO:', data1.length);
              setExcelData(data1);
              
              // Carica Foglio 2 (tariffario trasporti)
              console.log('Caricamento Foglio 2:', FOGLIO2_CSV_URL);
              const response2 = await fetch(FOGLIO2_CSV_URL);
              if (!response2.ok) throw new Error(`HTTP ${response2.status} - Foglio 2`);
              
              const csvText2 = await response2.text();
              console.log('Foglio 2 caricato, primi 500 caratteri:', csvText2.substring(0, 500));
              
              const lines2 = csvText2.split('\n');
              const headers2 = parseCSVLine(lines2[0]);
              console.log('Headers Foglio 2:', headers2);
              
              const data2 = [];
              for (let i = 1; i < lines2.length; i++) {
                if (!lines2[i].trim()) continue;
                
                const values = parseCSVLine(lines2[i]);
                const row = {};
                
                headers2.forEach((header, index) => {
                  let value = values[index] || '';
                  
                  // Rimuovi caratteri non numerici (‚Ç¨, spazi)
                  let cleanValue = value.replace(/‚Ç¨/g, '').replace(/\s/g, '').trim();
                  
                  // Gestione formato italiano:
                  if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    // Formato: 1.200,50 ‚Üí rimuovi punti, converti virgola in punto
                    cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                  } else if (cleanValue.includes(',')) {
                    // Formato: 1200,50 ‚Üí converti virgola in punto
                    cleanValue = cleanValue.replace(',', '.');
                  } else if (cleanValue.includes('.')) {
                    // Formato ambiguo: 1.200 o 1.2
                    const parts = cleanValue.split('.');
                    if (parts.length === 2 && parts[1].length === 3) {
                      // Es: 1.200 ‚Üí 1200
                      cleanValue = cleanValue.replace('.', '');
                    }
                  }
                  
                  if (!isNaN(cleanValue) && cleanValue !== '') {
                    row[header] = parseFloat(cleanValue);
                  } else {
                    row[header] = value;
                  }
                });
                
                // Almeno deve avere partenza, arrivo e costo
                if (row['Luogo di Partenza'] && row['Luogo di arrivo'] && row['Costo']) {
                  data2.push(row);
                }
              }
              
              console.log('Foglio 2: tariffario caricato:', data2.length, 'righe');
              if (data2.length > 0) {
                console.log('Prima riga tariffario:', data2[0]);
              }
              setTariffarioData(data2);
              
              // Destinazioni disponibili dal Foglio 1
              const dests = [...new Set(data1.map(r => r.DESTINAZIONE).filter(Boolean))];
              setAvailableDestinations(dests.sort());
              
              // Analizza destinazioni frequenti per suggerimenti Foglio 2
              analyzeSuggestedDestinations(data1, data2);
              
            } catch (error) {
              console.error('ERRORE:', error);
              setDataError(true);
              setErrorMessage(error.message);
            } finally {
              setIsLoading(false);
            }
          };

          // Cache per coordinate per evitare chiamate ripetute
          const coordsCache = {};

          const analyzeSuggestedDestinations = (foglio1Data, foglio2Data) => {
            console.log('=== ANALISI DESTINAZIONI FREQUENTI ===');
            
            // Crea mappa destinazioni nel Foglio 2 (gi√† nel tariffario)
            const tariffarioSet = new Set(
              (foglio2Data || []).map(t => 
                `${(t['Luogo di arrivo'] || '').trim().toUpperCase()}|${(t['Tipologia'] || '').trim().toUpperCase()}`
              )
            );
            
            // Conta occorrenze per destinazione + modalit√†
            const destCounts = {};
            foglio1Data.forEach(order => {
              const dest = order.DESTINAZIONE;
              const modalita = order["MODALITA'"];
              if (!dest || !modalita) return;
              
              const key = `${dest}|${modalita}`;
              if (!destCounts[key]) {
                destCounts[key] = {
                  destinazione: dest,
                  modalita: modalita,
                  count: 0,
                  porti: new Set(),
                  forwarders: new Set(),
                  costiTotali: [],
                  ultimoOrdine: order.ORDINE
                };
              }
              
              destCounts[key].count++;
              if (order.PORTO) destCounts[key].porti.add(order.PORTO);
              if (order.FORWARDER) destCounts[key].forwarders.add(order.FORWARDER);
              
              // Calcola costo totale (costi fissi + inland)
              const totale = (parseFloat(order['FREE OUT'] || 0) +
                             parseFloat(order['DELIVERY ORDER'] || 0) +
                             parseFloat(order['CICLO TERMINAL'] || 0) +
                             parseFloat(order['DOGANA'] || 0) +
                             parseFloat(order['DIRITTO FISSO'] || 0) +
                             parseFloat(order['INLAND'] || 0) +
                             parseFloat(order['FLEGT'] || 0) +
                             parseFloat(order['VISITA MERCE'] || 0) +
                             parseFloat(order['SOSTE'] || 0) +
                             parseFloat(order['SVINCOLO'] || 0));
              
              if (totale > 0) {
                destCounts[key].costiTotali.push(totale);
              }
            });
            
            // Filtra destinazioni con 3+ occorrenze e NON nel tariffario
            const suggestions = Object.values(destCounts)
              .filter(d => {
                const tariffKey = `${d.destinazione.trim().toUpperCase()}|${d.modalita.trim().toUpperCase()}`;
                return d.count >= 3 && !tariffarioSet.has(tariffKey);
              })
              .sort((a, b) => b.count - a.count)
              .slice(0, 10) // Top 10
              .map(d => {
                const avgCosto = d.costiTotali.length > 0
                  ? (d.costiTotali.reduce((a, b) => a + b, 0) / d.costiTotali.length).toFixed(2)
                  : 'N/D';
                
                return {
                  destinazione: d.destinazione,
                  modalita: d.modalita,
                  occorrenze: d.count,
                  portoComune: [...d.porti][0] || 'N/D',
                  forwarderComune: [...d.forwarders][0] || 'N/D',
                  costoMedio: avgCosto
                };
              });
            
            console.log(`Trovate ${suggestions.length} destinazioni frequenti da aggiungere al Foglio 2:`);
            suggestions.forEach((s, i) => {
              console.log(`${i+1}. ${s.destinazione} (${s.modalita}) - ${s.occorrenze}√ó - Media: ‚Ç¨${s.costoMedio}`);
            });
            
            setSuggestedDestinations(suggestions);
          };

          const getCoordinates = async (address) => {
            // Controlla cache
            if (coordsCache[address]) {
              console.log(`Cache hit per: ${address}`);
              return coordsCache[address];
            }
            
            const normalized = address.toLowerCase().trim();
            
            const cities = {
              'milano': { lat: 45.4642, lon: 9.19 },
              'roma': { lat: 41.9028, lon: 12.4964 },
              'napoli': { lat: 40.8518, lon: 14.2681 },
              'verona': { lat: 45.4384, lon: 10.9916 },
              'brescia': { lat: 45.5416, lon: 10.2118 },
              'oppeano': { lat: 45.316722, lon: 11.099167 },
              'adro': { lat: 45.6167, lon: 9.9667 },
              'salerno': { lat: 40.6824, lon: 14.7681 },
              'bergamo': { lat: 45.6983, lon: 9.6773 },
              'mantova': { lat: 45.1564, lon: 10.7914 },
              'cremona': { lat: 45.1333, lon: 10.0167 },
              'pavia': { lat: 45.1847, lon: 9.1582 },
              'torino': { lat: 45.0703, lon: 7.6869 },
              'genova': { lat: 44.4056, lon: 8.9463 },
              'bologna': { lat: 44.4949, lon: 11.3426 },
              'firenze': { lat: 43.7696, lon: 11.2558 },
              'venezia': { lat: 45.4408, lon: 12.3155 },
              'padova': { lat: 45.4064, lon: 11.8768 },
              'vicenza': { lat: 45.5455, lon: 11.5354 },
              'treviso': { lat: 45.6669, lon: 12.243 },
              'livorno': { lat: 43.5485, lon: 10.3106 },
              'civitavecchia': { lat: 42.0938, lon: 11.7967 },
              'ravenna': { lat: 44.4184, lon: 12.2035 },
              'trieste': { lat: 45.6495, lon: 13.7768 },
              'ariccia': { lat: 41.7292, lon: 12.6719 },
              'albano laziale': { lat: 41.7286, lon: 12.6581 },
              'isola del liri': { lat: 41.6808, lon: 13.5764 },
              'latina': { lat: 41.4677, lon: 12.9036 },
              'nepi': { lat: 42.2436, lon: 12.3453 },
              'san cesareo': { lat: 41.8167, lon: 12.8000 },
              'santa palomba': { lat: 41.7167, lon: 12.5667 },
              'prato': { lat: 43.8777, lon: 11.0955 },
              'cellole': { lat: 41.1147, lon: 13.9286 },
              'caserta': { lat: 41.0732, lon: 14.3328 },
              'aversa': { lat: 40.9732, lon: 14.2064 },
              'castellammare di stabia': { lat: 40.7017, lon: 14.4847 },
              'bari': { lat: 41.1171, lon: 16.8719 },
              'taranto': { lat: 40.4738, lon: 17.2405 },
              'foggia': { lat: 41.4621, lon: 15.5447 },
              'lecce': { lat: 40.3515, lon: 18.1750 },
              'brindisi': { lat: 40.6327, lon: 17.9419 },
              'palermo': { lat: 38.1157, lon: 13.3615 },
              'catania': { lat: 37.5079, lon: 15.0830 },
              'messina': { lat: 38.1938, lon: 15.5540 }
            };
            
            for (const [city, coords] of Object.entries(cities)) {
              if (normalized.includes(city)) {
                coordsCache[address] = coords;
                return coords;
              }
            }

            try {
              // Timeout ridotto a 2 secondi per geocoding
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 2000);
              
              const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}, Italy&limit=1`,
                { 
                  headers: { 'User-Agent': 'LogisticsCostCalculator/1.0' },
                  signal: controller.signal
                }
              );
              
              clearTimeout(timeoutId);
              
              const data = await response.json();
              if (data && data.length > 0) {
                const coords = {
                  lat: Number(Number(data[0].lat).toFixed(6)),
                  lon: Number(Number(data[0].lon).toFixed(6))
                };
                coordsCache[address] = coords;
                console.log(`Geocoded "${address}":`, coords);
                return coords;
              }
            } catch (error) {
              if (error.name === 'AbortError') {
                console.warn(`Geocoding timeout per ${address}`);
              } else {
                console.error('Geocoding error:', error);
              }
            }
            return null;
          };

          const calculateDistance = async (c1, c2) => {
            try {
              // OSRM con timeout di 3 secondi per evitare attese infinite
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              const url = `https://router.project-osrm.org/route/v1/driving/${c1.lon},${c1.lat};${c2.lon},${c2.lat}?overview=false`;
              const response = await fetch(url, { signal: controller.signal });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) {
                throw new Error('OSRM API error');
              }
              
              const data = await response.json();
              
              if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                const distanceKm = data.routes[0].distance / 1000;
                return distanceKm;
              } else {
                console.warn('OSRM fallito, uso Haversine');
                return calculateDistanceHaversine(c1, c2);
              }
            } catch (error) {
              if (error.name === 'AbortError') {
                console.warn('OSRM timeout, uso Haversine');
              } else {
                console.error('Errore OSRM:', error);
              }
              return calculateDistanceHaversine(c1, c2);
            }
          };
          
          const calculateDistanceHaversine = (c1, c2) => {
            const R = 6371;
            const dLat = (c2.lat - c1.lat) * Math.PI / 180;
            const dLon = (c2.lon - c1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(c1.lat * Math.PI / 180) * Math.cos(c2.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
          };

          const calculateBestOption = async () => {
            if (!destinazione || !modalita || !tonnellate) {
              alert('Compila tutti i campi');
              return;
            }
            
            setIsCalculating(true);
            
            try {
              console.log('=== INIZIO CALCOLO ===');
              console.log('Modalit√† richiesta:', modalita);
              console.log('Destinazione richiesta:', destinazione);
              console.log('Totale ordini disponibili (Foglio 1):', excelData.length);
              
              const filtered = excelData.filter(r => {
                const modalitaRow = r["MODALITA'"];
                const hasEuroTon = r['‚Ç¨/TON'];
                return modalitaRow === modalita && hasEuroTon;
              });
              
              console.log('Ordini filtrati per modalit√† "' + modalita + '":', filtered.length);
              
              if (filtered.length === 0) {
                alert('Nessun ordine per questa modalit√†');
                setIsCalculating(false);
                return;
              }
              
              // Cerca match esatto nella destinazione
              const exact = filtered.filter(r => r.DESTINAZIONE === destinazione);
              
              let ordersToUse = [];
              let isEstimated = false;
              let referenceDestinations = [];
              let useTariffario = false;
              let tariffarioMatch = null;
              
              if (exact.length > 0) {
                // Match esatto trovato nel Foglio 1
                console.log('‚úì Match esatto trovato nel Foglio 1');
                ordersToUse = exact;
              } else {
                // Nessun match esatto: cerca nel tariffario (Foglio 2)
                console.log('‚ö†Ô∏è Nessun match esatto, cerco nel tariffario...');
                
                if (tariffarioData && tariffarioData.length > 0) {
                  console.log('=== RICERCA NEL TARIFFARIO ===');
                  console.log('Destinazione cercata:', destinazione);
                  console.log('Modalit√† cercata:', modalita);
                  console.log('Totale righe tariffario:', tariffarioData.length);
                  console.log('Prima riga tariffario (esempio):', tariffarioData[0]);
                  console.log('Nomi colonne disponibili:', Object.keys(tariffarioData[0]));
                  
                  // Cerca nel tariffario una corrispondenza di destinazione e tipologia
                  const tariffarioFiltered = tariffarioData.filter(t => {
                    const arrivo = t['Luogo di arrivo'] || '';
                    const tipologia = t['Tipologia'] || '';
                    
                    console.log('Controllo riga:', {
                      arrivo: arrivo,
                      tipologia: tipologia,
                      arrivoMatch: arrivo.toLowerCase().trim() === destinazione.toLowerCase().trim(),
                      tipologiaMatch: tipologia.toUpperCase() === modalita.toUpperCase()
                    });
                    
                    // Normalizza confronto (case-insensitive, trim)
                    const arrivoMatch = arrivo.toLowerCase().trim() === destinazione.toLowerCase().trim();
                    const tipologiaMatch = tipologia.toUpperCase() === modalita.toUpperCase();
                    
                    return arrivoMatch && tipologiaMatch;
                  });
                  
                  console.log('Tariffario: trovate', tariffarioFiltered.length, 'corrispondenze');
                  
                  if (tariffarioFiltered.length > 0) {
                    // Usa il tariffario
                    useTariffario = true;
                    tariffarioMatch = tariffarioFiltered[0]; // Prendi la prima corrispondenza
                    console.log('‚úì Uso tariffario:', tariffarioMatch);
                  }
                }
                
                if (!useTariffario) {
                  // Fallback: stima basata su destinazioni vicine (logica originale)
                  console.log('‚ö†Ô∏è Nessun match nel tariffario, stimo da destinazioni vicine...');
                  console.log('üí° SUGGERIMENTO: Aggiungi questa destinazione al Foglio 2 (tariffario) per calcoli istantanei!');
                  isEstimated = true;
                  const targetCoords = await getCoordinates(destinazione);
                  
                  if (!targetCoords) {
                    alert('Impossibile trovare la destinazione');
                    setIsCalculating(false);
                    return;
                  }
                  
                  console.log(`Calcolo distanze da tutte le ${filtered.length} destinazioni...`);
                  
                  // USA TUTTE le destinazioni TRUCK disponibili per trovare la migliore
                  const samplesToCheck = filtered;
                  
                  // PARALLELO: Calcola tutte le coordinate insieme
                  const coordsPromises = samplesToCheck.map(row => getCoordinates(row.DESTINAZIONE));
                  const allCoords = await Promise.all(coordsPromises);
                  
                  // PARALLELO: Calcola tutte le distanze insieme (invece di una alla volta)
                  const distancePromises = allCoords.map((coords, idx) => {
                    if (coords) {
                      return calculateDistance(targetCoords, coords).then(distance => ({
                        destination: samplesToCheck[idx].DESTINAZIONE,
                        distance: distance
                      }));
                    }
                    return null;
                  });
                  
                  const results = await Promise.all(distancePromises);
                  
                  results.forEach(result => {
                    if (result) {
                      destsWithDist.push(result);
                      console.log(`‚úì ${result.destination}: ${result.distance.toFixed(0)}km`);
                    }
                  });
                  
                  destsWithDist.sort((a, b) => a.distance - b.distance);
                  const nearest = destsWithDist.slice(0, 3); // Top 3 pi√π vicine
                  referenceDestinations = nearest;
                  
                  console.log('Destinazioni pi√π vicine trovate:');
                  nearest.forEach((d, i) => {
                    console.log(`${i+1}. ${d.destination}: ${d.distance.toFixed(0)}km`);
                  });
                  
                  nearest.forEach(nd => {
                    const orders = filtered.filter(r => r.DESTINAZIONE === nd.destination);
                    ordersToUse.push(...orders);
                  });
                }
              }
              
              const ton = parseFloat(tonnellate);
              
              // Se usiamo il tariffario, calcolo semplificato
              if (useTariffario) {
                console.log('=== DEBUG TARIFFARIO ===');
                console.log('Riga tariffario trovata:', tariffarioMatch);
                console.log('Valore COSTO raw:', tariffarioMatch['Costo']);
                console.log('Valore PARTNER raw:', tariffarioMatch['Partner']);
                console.log('Valore LUOGO DI PARTENZA raw:', tariffarioMatch['Luogo di Partenza']);
                
                const costoTrasporto = parseFloat(tariffarioMatch['Costo']);
                const partner = tariffarioMatch['Partner'] || 'N/D';
                const partenza = tariffarioMatch['Luogo di Partenza'] || 'N/D';
                
                console.log('Costo dopo parseFloat:', costoTrasporto);
                console.log('Partner:', partner);
                console.log('Partenza:', partenza);
                
                setRisultato({
                  porto: partenza,
                  forwarder: partner,
                  costiFissi: '0.00',
                  inland: costoTrasporto.toFixed(2),
                  costoTotale: costoTrasporto.toFixed(2),
                  costoPerTon: (costoTrasporto / ton).toFixed(2),
                  tonnellate: ton,
                  numOrdiniStorici: 0,
                  isEstimated: false,
                  isTariffario: true,
                  referenceDestinations: []
                });
                
                setIsCalculating(false);
                return;
              }
              
              // Altrimenti, logica originale con ordini storici
              if (ordersToUse.length === 0) {
                alert('Nessun ordine trovato');
                setIsCalculating(false);
                return;
              }
              
              const combinations = {};
              console.log('=== CREAZIONE COMBINAZIONI ===');
              console.log('Numero ordini da processare:', ordersToUse.length);
              ordersToUse.forEach((order, idx) => {
                console.log(`Ordine ${idx + 1}:`, {
                  ordine: order.ORDINE,
                  porto: order.PORTO,
                  forwarder: order.FORWARDER,
                  euroTon: order['‚Ç¨/TON'],
                  destinazione: order.DESTINAZIONE
                });
                
                const key = `${order.PORTO}|${order.FORWARDER}`;
                console.log(`  Key creata: "${key}"`);
                
                if (!combinations[key]) {
                  combinations[key] = { 
                    porto: order.PORTO, 
                    forwarder: order.FORWARDER, 
                    costs: [],
                    destinations: []
                  };
                  console.log(`  ‚úì Nuova combinazione creata`);
                }
                combinations[key].costs.push(parseFloat(order['‚Ç¨/TON']));
                if (!combinations[key].destinations.includes(order.DESTINAZIONE)) {
                  combinations[key].destinations.push(order.DESTINAZIONE);
                }
              });
              
              console.log('Totale combinazioni create:', Object.keys(combinations).length);
              console.log('Combinazioni:', Object.keys(combinations));
              
              // Verifica che ci siano combinazioni valide
              if (Object.keys(combinations).length === 0) {
                alert('Nessuna combinazione porto/forwarder trovata');
                setIsCalculating(false);
                return;
              }
              
              const portCoords = {
                'VENEZIA': { lat: 45.4408, lon: 12.3155 },
                'TRIESTE': { lat: 45.6495, lon: 13.7768 },
                'GENOVA': { lat: 44.4056, lon: 8.9463 },
                'LIVORNO': { lat: 43.5485, lon: 10.3106 },
                'RAVENNA': { lat: 44.4184, lon: 12.2035 },
                'NAPOLI': { lat: 40.8518, lon: 14.2681 },
                'SALERNO': { lat: 40.6824, lon: 14.7681 },
                'CIVITAVECCHIA': { lat: 42.0938, lon: 11.7967 }
              };
              
              let bestOption = null;
              let lowestCost = Infinity;
              
              if (isEstimated) {
                const targetCoords = await getCoordinates(destinazione);
                console.log('=== CALCOLO DISTANZE PORTI ===');
                
                // PARALLELO: Calcola distanze di tutti i porti insieme
                const portDistancePromises = Object.values(combinations).map(async (combo) => {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  const portCoord = portCoords[combo.porto.toUpperCase()];
                  
                  if (portCoord && targetCoords) {
                    const distance = await calculateDistance(targetCoords, portCoord);
                    console.log(`Porto ${combo.porto}:`, {
                      distanza_km: distance.toFixed(1),
                      costo_medio: avgCost.toFixed(2)
                    });
                    
                    return {
                      ...combo,
                      avgCost,
                      numOrders: combo.costs.length,
                      portDistance: distance
                    };
                  }
                  return null;
                });
                
                const combosWithDistance = (await Promise.all(portDistancePromises)).filter(Boolean);
                
                // Per le STIME: ordina SOLO per distanza porto (il costo √® meno importante)
                combosWithDistance.sort((a, b) => a.portDistance - b.portDistance);
                
                console.log('--- Porti ordinati per distanza ---');
                combosWithDistance.forEach((c, i) => {
                  console.log(`${i+1}. ${c.porto} - ${c.portDistance.toFixed(0)}km - ‚Ç¨${c.avgCost.toFixed(2)}/ton`);
                });
                
                if (combosWithDistance.length > 0) {
                  bestOption = combosWithDistance[0];
                  console.log('‚úì PORTO SCELTO:', bestOption.porto, '-', bestOption.portDistance.toFixed(0), 'km');
                } else {
                  alert('Impossibile calcolare la distanza dai porti');
                  setIsCalculating(false);
                  return;
                }
                
              } else {
                Object.values(combinations).forEach(combo => {
                  const avgCost = combo.costs.reduce((a, b) => a + b, 0) / combo.costs.length;
                  if (avgCost < lowestCost) {
                    lowestCost = avgCost;
                    bestOption = { ...combo, avgCost, numOrders: combo.costs.length };
                  }
                });
              }
              
              // Verifica finale che bestOption sia stato trovato
              if (!bestOption) {
                alert('Impossibile determinare la migliore opzione');
                setIsCalculating(false);
                return;
              }
              
              const ordersForChosen = ordersToUse.filter(order => 
                order.PORTO === bestOption.porto && 
                order.FORWARDER === bestOption.forwarder
              );
              
              let totalCostiFissi = 0;
              let totalInland = 0;
              let totalOrders = 0;
              
              ordersForChosen.forEach((order, idx) => {
                const freeOut = parseFloat(order['FREE OUT'] || 0);
                const deliveryOrder = parseFloat(order['DELIVERY ORDER'] || 0);
                const cicloTerminal = parseFloat(order['CICLO TERMINAL'] || 0);
                const dogana = parseFloat(order['DOGANA'] || 0);
                const dirittoFisso = parseFloat(order['DIRITTO FISSO'] || 0);
                const flegt = parseFloat(order['FLEGT'] || 0);
                const visitaMerce = parseFloat(order['VISITA MERCE'] || 0);
                const soste = parseFloat(order['SOSTE'] || 0);
                const svincolo = parseFloat(order['SVINCOLO'] || 0);
                const inland = parseFloat(order['INLAND'] || 0);
                
                const costiFissi = freeOut + deliveryOrder + cicloTerminal + dogana + 
                                   dirittoFisso + flegt + visitaMerce + soste + svincolo;
                
                totalCostiFissi += costiFissi;
                totalInland += inland;
                totalOrders++;
              });
              
              const avgCostiFissi = totalCostiFissi / totalOrders;
              const avgInland = totalInland / totalOrders;
              
              console.log('--- MEDIE PER', bestOption.porto, '+', bestOption.forwarder, '---');
              console.log('MEDIA Costi Fissi:', avgCostiFissi.toFixed(2), '‚Ç¨');
              console.log('MEDIA INLAND:', avgInland.toFixed(2), '‚Ç¨');
              
              let adjustedInland = avgInland;
              if (isEstimated && referenceDestinations.length > 0) {
                const targetCoords = await getCoordinates(destinazione);
                
                let avgPortDistToRef = 0;
                let countDistances = 0;
                
                for (const order of ordersForChosen) {
                  const refCoords = await getCoordinates(order.DESTINAZIONE);
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (refCoords && portCoord) {
                    const dist = await calculateDistance(portCoord, refCoords);
                    avgPortDistToRef += dist;
                    countDistances++;
                  }
                }
                
                if (countDistances > 0) {
                  avgPortDistToRef = avgPortDistToRef / countDistances;
                  
                  const portCoord = portCoords[bestOption.porto.toUpperCase()];
                  if (portCoord && targetCoords) {
                    const portDistToTarget = await calculateDistance(portCoord, targetCoords);
                    const distanceRatio = portDistToTarget / avgPortDistToRef;
                    adjustedInland = avgInland * distanceRatio;
                    
                    console.log('=== STIMA INLAND ===');
                    console.log('INLAND medio storico:', avgInland.toFixed(2), '‚Ç¨');
                    console.log('Distanza media porto‚Üídestinazioni storiche:', avgPortDistToRef.toFixed(0), 'km');
                    console.log('Distanza porto‚Üítarget:', portDistToTarget.toFixed(0), 'km');
                    console.log('INLAND stimato:', adjustedInland.toFixed(2), '‚Ç¨');
                  }
                }
              }
              
              const costoTotale = avgCostiFissi + adjustedInland;
              
              setRisultato({
                porto: bestOption.porto,
                forwarder: bestOption.forwarder,
                costiFissi: avgCostiFissi.toFixed(2),
                inland: adjustedInland.toFixed(2),
                costoTotale: costoTotale.toFixed(2),
                costoPerTon: (costoTotale / ton).toFixed(2),
                tonnellate: ton,
                numOrdiniStorici: bestOption.numOrders,
                isEstimated: isEstimated,
                isTariffario: false,
                referenceDestinations: referenceDestinations
              });
              
            } catch (error) {
              console.error('Errore calcolo:', error);
              alert('Errore nel calcolo');
            } finally {
              setIsCalculating(false);
            }
          };

          if (isLoading) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                <div className="text-center">
                  <Loader />
                  <p className="text-gray-600 text-lg mt-4">Caricamento dati...</p>
                </div>
              </div>
            );
          }

          if (dataError) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md">
                  <AlertCircle />
                  <h2 className="text-xl font-bold mb-4">Errore Caricamento</h2>
                  <p className="text-gray-600 mb-4">Impossibile caricare i dati.</p>
                  <div className="bg-red-50 p-3 rounded mb-4">
                    <p className="text-sm text-red-800">{errorMessage}</p>
                  </div>
                  <p className="text-sm text-gray-600 mb-4">Apri Console (F12) per dettagli.</p>
                  <button onClick={loadData} className="w-full bg-indigo-600 text-white py-3 rounded-lg">Riprova</button>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
              <div className="max-w-3xl mx-auto">
                <div className="bg-white rounded-2xl shadow-xl p-8 mb-6">
                  <div className="flex items-center gap-3 mb-6">
                    <Package />
                    <h1 className="text-3xl font-bold text-gray-800">Calcolo Costi Logistici</h1>
                  </div>

                  <div className="bg-green-50 border-l-4 border-green-500 p-4 mb-6">
                    <p className="text-sm text-green-800">
                      <strong>‚úì Connesso</strong>
                    </p>
                    <p className="text-xs text-green-700 mt-1">
                      Foglio 1: {excelData.length} ordini ‚Ä¢ Foglio 2: {tariffarioData ? tariffarioData.length : 0} tariffe
                    </p>
                  </div>

                  {suggestedDestinations.length > 0 && (
                    <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                      <div className="flex items-center justify-between mb-2">
                        <p className="text-sm font-semibold text-blue-800">
                          üí° Suggerimenti Tariffario
                        </p>
                        <button
                          onClick={() => setSuggestedDestinations([])}
                          className="text-xs text-blue-600 hover:text-blue-800"
                        >
                          Nascondi
                        </button>
                      </div>
                      <p className="text-xs text-blue-700 mb-3">
                        Queste destinazioni compaiono spesso (3+). Aggiungile al Foglio 2 per calcoli istantanei:
                      </p>
                      <div className="bg-white rounded p-3 max-h-60 overflow-y-auto">
                        <table className="w-full text-xs">
                          <thead>
                            <tr className="border-b">
                              <th className="text-left py-1 pr-2">Destinazione</th>
                              <th className="text-left py-1 px-2">Tipo</th>
                              <th className="text-center py-1 px-2">√ó</th>
                              <th className="text-left py-1 px-2">Porto</th>
                              <th className="text-right py-1 pl-2">Costo Medio</th>
                            </tr>
                          </thead>
                          <tbody>
                            {suggestedDestinations.map((s, i) => (
                              <tr key={i} className="border-b hover:bg-gray-50">
                                <td className="py-2 pr-2 text-gray-800">{s.destinazione}</td>
                                <td className="py-2 px-2 text-gray-600">{s.modalita}</td>
                                <td className="py-2 px-2 text-center font-semibold text-blue-600">{s.occorrenze}</td>
                                <td className="py-2 px-2 text-gray-600">{s.portoComune}</td>
                                <td className="py-2 pl-2 text-right font-semibold text-green-700">‚Ç¨{s.costoMedio}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                      <p className="text-xs text-blue-600 mt-2">
                        üìã Copia questi valori nel Foglio 2: Porto | Destinazione | Tipo | Costo | Partner
                      </p>
                    </div>
                  )}

                  <div className="space-y-6">
                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <MapPin />
                        Destinazione
                      </label>
                      <input
                        type="text"
                        value={destinazione}
                        onChange={(e) => setDestinazione(e.target.value)}
                        placeholder="es. Milano"
                        list="dests"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                      <datalist id="dests">
                        {availableDestinations.map(d => <option key={d} value={d} />)}
                      </datalist>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold flex items-center gap-2">
                        <Truck />
                        Modalit√†
                      </label>
                      <select value={modalita} onChange={(e) => setModalita(e.target.value)} className="w-full px-4 py-3 border rounded-lg">
                        <option value="">Seleziona...</option>
                        <option value="CONTAINER">Container</option>
                        <option value="TRUCK">Camion</option>
                      </select>
                    </div>

                    <div>
                      <label className="block mb-2 font-semibold">Tonnellate</label>
                      <input
                        type="number"
                        value={tonnellate}
                        onChange={(e) => setTonnellate(e.target.value)}
                        placeholder="es. 25"
                        step="0.01"
                        className="w-full px-4 py-3 border rounded-lg"
                      />
                    </div>

                    <button
                      onClick={calculateBestOption}
                      disabled={isCalculating}
                      className="w-full bg-indigo-600 text-white font-bold py-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-400"
                    >
                      <Calculator />
                      {isCalculating ? 'Calcolo...' : 'Calcola Preventivo'}
                    </button>
                  </div>
                </div>

                {risultato && (
                  <div className="bg-white rounded-2xl shadow-xl p-8">
                    {risultato.isTariffario && (
                      <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                        <p className="text-sm text-blue-800">
                          <strong>üìã Tariffario</strong> - Costo da tariffario trasporti
                        </p>
                      </div>
                    )}
                    
                    {risultato.isEstimated && !risultato.isTariffario && (
                      <div className="bg-amber-50 border-l-4 border-amber-500 p-4 mb-6">
                        <p className="text-sm text-amber-800">
                          <strong>‚ö†Ô∏è Stima</strong> - Basata su {risultato.referenceDestinations.length} destinazioni vicine
                        </p>
                      </div>
                    )}

                    <div className="flex items-center gap-3 mb-6">
                      <TrendingDown />
                      <h2 className="text-2xl font-bold">Preventivo</h2>
                    </div>

                    <div className="grid md:grid-cols-2 gap-4 mb-6">
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">{risultato.isTariffario ? 'Partenza' : 'Porto'}</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.porto}</p>
                      </div>
                      <div className="bg-indigo-50 p-6 rounded-xl">
                        <p className="text-sm text-gray-600">{risultato.isTariffario ? 'Partner' : 'Forwarder'}</p>
                        <p className="text-2xl font-bold text-indigo-700">{risultato.forwarder}</p>
                      </div>
                    </div>

                    <div className="bg-green-50 p-6 rounded-xl mb-6">
                      <h3 className="font-semibold text-gray-700 mb-4">Riepilogo Costi</h3>
                      <div className="space-y-3">
                        {!risultato.isTariffario && (
                          <div className="flex justify-between items-center">
                            <span className="text-sm text-gray-600">Costi Fissi (porto + dogana + servizi)</span>
                            <span className="text-lg font-bold text-gray-800">‚Ç¨{risultato.costiFissi}</span>
                          </div>
                        )}
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">
                            {risultato.isTariffario ? 'Costo Trasporto' : `Inland (trasporto ${risultato.porto} ‚Üí destinazione)`}
                          </span>
                          <span className="text-lg font-bold text-gray-800">‚Ç¨{risultato.inland}</span>
                        </div>
                        <div className="border-t-2 border-green-200 pt-3 mt-3">
                          <div className="flex justify-between items-center">
                            <span className="text-base font-semibold text-gray-700">Costo Totale</span>
                            <span className="text-2xl font-bold text-green-700">‚Ç¨{risultato.costoTotale}</span>
                          </div>
                          <div className="flex justify-between items-center mt-2">
                            <span className="text-sm text-gray-600">Costo per Tonnellata</span>
                            <span className="text-lg font-bold text-green-700">‚Ç¨{risultato.costoPerTon}/ton</span>
                          </div>
                          <p className="text-xs text-gray-500 mt-2">
                            ({risultato.tonnellate} tonnellate)
                          </p>
                        </div>
                      </div>
                    </div>

                    {!risultato.isTariffario && risultato.numOrdiniStorici > 0 && (
                      <p className="text-sm text-gray-500 mt-4">Basato su {risultato.numOrdiniStorici} ordini storici</p>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
